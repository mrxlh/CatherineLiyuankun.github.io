<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>岚</title>
  <icon>https://www.gravatar.com/avatar/0e57272b72bf1a283c89417a9bc99517</icon>
  <subtitle>Talk to myself.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://catherineliyuankun.github.io/"/>
  <updated>2019-10-31T16:12:38.334Z</updated>
  <id>https://catherineliyuankun.github.io/</id>
  
  <author>
    <name>Yuankun Li</name>
    <email>muzilan1@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>英文标点符号+运算符号</title>
    <link href="https://catherineliyuankun.github.io/%E8%8B%B1%E6%96%87%E6%A0%87%E7%82%B9%E7%AC%A6%E5%8F%B7-%E8%BF%90%E7%AE%97%E7%AC%A6%E5%8F%B7.html"/>
    <id>https://catherineliyuankun.github.io/英文标点符号-运算符号.html</id>
    <published>2019-10-30T08:45:20.000Z</published>
    <updated>2019-10-31T16:12:38.334Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th>符号</th><th>英文含义</th><th>读音</th><th>中文含义</th></tr></thead><tbody><tr><td>．</td><td>period or full stop</td><td>英  [ˌsemiˈkəʊlən; ˌsemiˈkəʊlɒn]  美  [ˈsemikoʊlən]</td><td>句号</td></tr><tr><td>，</td><td>comma</td><td></td><td>逗号</td></tr><tr><td>：</td><td>colon</td><td></td><td>冒号</td></tr><tr><td>；</td><td>semicolon</td><td></td><td>分号</td></tr><tr><td>！</td><td>exclamation mark</td><td></td><td>惊叹号</td></tr><tr><td>？</td><td>question mark</td><td></td><td>问号</td></tr><tr><td>-</td><td>hyphen</td><td></td><td>连字符</td></tr><tr><td>*</td><td>asterisk</td><td></td><td>星号</td></tr><tr><td>’</td><td>apostrophe</td><td></td><td>所有格符号，单词内部的省略</td></tr><tr><td>—</td><td>dash</td><td></td><td>破折号</td></tr><tr><td>_</td><td>underscore</td><td></td><td></td></tr><tr><td>‘’</td><td>single quotation marks</td><td>英  [kwəʊˈteɪʃn]  美  [kwoʊˈteɪʃn]</td><td>单引号</td></tr><tr><td>“ ”</td><td>double quotation marks</td><td></td><td>双引号</td></tr><tr><td>( )</td><td>parenthesis or round brackets</td><td></td><td>圆括号</td></tr><tr><td>[ ]</td><td>square brackets</td><td>美  ['brækɪts]</td><td>方括号</td></tr><tr><td>&lt;&gt;</td><td>Angle brackets</td><td></td><td>尖括号</td></tr><tr><td>{}</td><td>curly brackets or braces</td><td></td><td>大括号</td></tr><tr><td>《》</td><td>French quotes</td><td></td><td>法文引号；书名号</td></tr><tr><td>…</td><td>ellipsis</td><td></td><td>省略号</td></tr><tr><td>¨</td><td>tandem colon</td><td></td><td>双点号</td></tr><tr><td>&quot;</td><td>ditto</td><td></td><td>同上</td></tr><tr><td>‖</td><td>parallel</td><td></td><td>双线号</td></tr><tr><td>／</td><td>slash or virgule or diagonal mark</td><td></td><td>斜线号</td></tr><tr><td>＆</td><td>ampersand = and</td><td></td><td></td></tr><tr><td>～</td><td>tilde or swung dash</td><td></td><td>代字号</td></tr><tr><td>§</td><td>section; division</td><td></td><td>分节号</td></tr><tr><td>→</td><td>arrow</td><td></td><td>箭号；参见号</td></tr><tr><td></td><td>vertical bar</td><td></td><td>竖线</td></tr><tr><td>\</td><td>backslash</td><td></td><td>反斜线</td></tr></tbody></table><p>=====================</p><p>附：部分数学符号的英文名称</p><table><thead><tr><th>符号</th><th>英文含义</th><th>中文含义</th></tr></thead><tbody><tr><td>＋</td><td>plus</td><td>加号；正号</td></tr><tr><td>－</td><td>minus</td><td>减号；负号</td></tr><tr><td>±</td><td>plus or minus</td><td>正负号</td></tr><tr><td>×</td><td>is multiplied by</td><td>乘号</td></tr><tr><td>÷</td><td>is divided by</td><td>除号</td></tr><tr><td>＝</td><td>is equal to</td><td>等于号</td></tr><tr><td>≠</td><td>is not equal to</td><td>不等于号</td></tr><tr><td>≡</td><td>is equivalent to</td><td>全等于号</td></tr><tr><td>≌</td><td>is equal to or approximately equal to</td><td>等于或约等于号</td></tr><tr><td>≈</td><td>is approximately equal to</td><td>约等于号</td></tr><tr><td>＜</td><td>less than sign</td><td>小于号</td></tr><tr><td>＞</td><td>more than or greater than sign</td><td>大于号</td></tr><tr><td>≮</td><td>is not less than</td><td>不小于号</td></tr><tr><td>≯</td><td>is not more than</td><td>不大于号</td></tr><tr><td>≤</td><td>is less than or equal to</td><td>小于或等于号</td></tr><tr><td>≥</td><td>is more than or equal to</td><td>大于或等于号</td></tr><tr><td>％</td><td>per cent</td><td>百分之…</td></tr><tr><td>‰</td><td>per mill</td><td>千分之…</td></tr><tr><td>∞</td><td>infinity</td><td>无限大号</td></tr><tr><td>∝</td><td>varies as</td><td>与…成比例</td></tr><tr><td>√</td><td>(square) root</td><td>平方根</td></tr><tr><td>∵</td><td>since; because</td><td>因为</td></tr><tr><td>∴</td><td>hence</td><td>所以</td></tr><tr><td>∷</td><td>equals, as (proportion)</td><td>等于，成比例</td></tr><tr><td>∠</td><td>angle</td><td>角</td></tr><tr><td>⌒</td><td>semicircle</td><td>半圆</td></tr><tr><td>⊙</td><td>circle</td><td>圆</td></tr><tr><td>○</td><td>circumference</td><td>圆周</td></tr><tr><td>△</td><td>triangle</td><td>三角形</td></tr><tr><td>⊥</td><td>perpendicular to</td><td>垂直于</td></tr><tr><td>∪</td><td>union of</td><td>并，合集</td></tr><tr><td>∩</td><td>intersection of</td><td>交，通集</td></tr><tr><td>∫</td><td>the integral of</td><td>…的积分</td></tr><tr><td>∑</td><td>(sigma) summation of</td><td>总和</td></tr><tr><td>°</td><td>degree</td><td>度</td></tr><tr><td>′</td><td>minute</td><td>分</td></tr><tr><td>″</td><td>second</td><td>秒</td></tr><tr><td>＃</td><td>number</td><td>…号</td></tr><tr><td>℃</td><td>Celsius system</td><td>摄氏度</td></tr><tr><td>＠</td><td>at</td><td>在</td></tr></tbody></table><h1 id="参考文章">参考文章</h1><ul><li><a href="http://www.ruanyifeng.com/blog/2007/07/english_punctuation.html" target="_blank" rel="noopener">标点符号的英语名称</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;符号&lt;/th&gt;
&lt;th&gt;英文含义&lt;/th&gt;
&lt;th&gt;读音&lt;/th&gt;
&lt;th&gt;中文含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;．&lt;/td&gt;
&lt;td&gt;period or full stop&lt;/td&gt;
      
    
    </summary>
    
      <category term="English Learning" scheme="https://catherineliyuankun.github.io/categories/English-Learning/"/>
    
      <category term="日常英语" scheme="https://catherineliyuankun.github.io/categories/English-Learning/%E6%97%A5%E5%B8%B8%E8%8B%B1%E8%AF%AD/"/>
    
    
  </entry>
  
  <entry>
    <title>Promise Vs setTimeout</title>
    <link href="https://catherineliyuankun.github.io/Promise-Vs-setTimeout.html"/>
    <id>https://catherineliyuankun.github.io/Promise-Vs-setTimeout.html</id>
    <published>2019-10-29T13:17:43.000Z</published>
    <updated>2019-11-05T09:13:00.584Z</updated>
    
    <content type="html"><![CDATA[<p>了解这个，就得了解JavaScript异步编程，了解任务队列才能知其根本。</p><p>一个事件循环（event loop）+多个任务队列（task queue）</p><h2 id="事件循环-event-loop">事件循环（event loop）</h2><h2 id="task-queue">Task Queue</h2><h3 id="macrotask-queue-宏任务队列">Macrotask Queue 宏任务队列:</h3><ul><li>setTimeout</li><li>setInterval</li><li>setImmediate</li><li>requestAnimationFrame</li><li>UI rendeing</li><li>NodeJS中的`I/O （fs.readFile）等</li></ul><h3 id="microtask-queue-微任务队列">Microtask Queue 微任务队列:</h3><p>主要包括两类：</p><ul><li>独立回调microTask：如Promise，其成功／失败回调函数相互独立；</li><li>复合回调microTask：如 Object.observe, MutationObserver 和NodeJs中的 process.nextTick ，不同状态回调在同一函数体；</li></ul><h3 id="macrotask-microtask-两者关系">MacroTask MicroTask 两者关系</h3><p>入栈过程：</p><blockquote><ol><li>开始执行JavaScript脚本，将任务JavaScript Run入栈macroTask队列；</li><li>同步resolvePromise后；</li><li>入栈<code>第一个</code>setTimeout任务进入macroTask队列</li><li>入栈Proimse.then任务进入microTask队列；</li><li>入栈第二个setTimeout任务进入macroTask队列；<br>出栈执行过程：</li><li>同步执行代码，退出第一个macroTask，即JavaScript Run;</li><li>按顺序执行microTask queue 所有microTask；</li><li>执行下一个macroTask；</li></ol></blockquote><p>可以参考这个流程图：<br><img src="http://www.programmersought.com/images/250/ae6f91d1cb68f1e5d05b95a66a2cba72.png" alt="流程图"></p><h2 id="show-me-the-code">Show me the code</h2><p>例题1-5 来自<a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="noopener">ES6 Book </a>：</p><h3 id="例题1">例题1</h3><p>Promise 新建后就会立即执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Promise'</span>);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'resolved.'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Hi!'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise</span></span><br><span class="line"><span class="comment">// Hi!</span></span><br><span class="line"><span class="comment">// resolved</span></span><br></pre></td></tr></table></figure><p>上面代码中，Promise 新建后立即执行，所以首先输出的是Promise。然后，then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以resolved最后输出。</p><h3 id="例题2">例题2</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(r);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>上面代码中，调用resolve(1)以后，后面的console.log(2)还是会执行，并且会首先打印出来。这是因为立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。</p><p>一般来说，调用resolve或reject以后，Promise 的使命就完成了，后继操作应该放到then方法里面，而不应该直接写在resolve或reject的后面。所以，最好在它们前面加上return语句，这样就不会有意外。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> resolve(<span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 后面的语句不会执行</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="例题3">例题3</h3><p>需要注意的是，立即resolve()的 Promise 对象，是在本轮“事件循环”（event loop）的结束时执行，而不是在下一轮“事件循环”的开始时。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'three'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'two'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'one'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// one</span></span><br><span class="line"><span class="comment">// two</span></span><br><span class="line"><span class="comment">// three</span></span><br></pre></td></tr></table></figure><p>上面代码中，setTimeout(fn, 0)在下一轮“事件循环”开始时执行，Promise.resolve()在本轮“事件循环”结束时执行，console.log(‘one’)则是立即执行，因此最先输出。</p><h3 id="例题4-promise-try">例题4 Promise.try</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> f = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'now'</span>);</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(f);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'next'</span>);</span><br><span class="line"><span class="comment">// next</span></span><br><span class="line"><span class="comment">// now</span></span><br></pre></td></tr></table></figure><p>上面代码中，函数f是同步的，但是用 Promise 包装了以后，就变成异步执行了。</p><p>那么有没有一种方法，让同步函数同步执行，异步函数异步执行，并且让它们具有统一的 API 呢？回答是可以的，并且还有两种写法。第一种写法是用async函数来写。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> f = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'now'</span>);</span><br><span class="line">(<span class="keyword">async</span> () =&gt; f())();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'next'</span>);</span><br><span class="line"><span class="comment">// now</span></span><br><span class="line"><span class="comment">// next</span></span><br></pre></td></tr></table></figure><p>上面代码中，第二行是一个立即执行的匿名函数，会立即执行里面的async函数，因此如果f是同步的，就会得到同步的结果；如果f是异步的，就可以用then指定下一步，就像下面的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; f())()</span><br><span class="line">.then(...)</span><br></pre></td></tr></table></figure><p>需要注意的是，async () =&gt; f()会吃掉f()抛出的错误。所以，如果想捕获错误，要使用promise.catch方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; f())()</span><br><span class="line">.then(...)</span><br><span class="line">.catch(...)</span><br></pre></td></tr></table></figure><p>第二种写法是使用new Promise()。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> f = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'now'</span>);</span><br><span class="line">(</span><br><span class="line">  () =&gt; <span class="keyword">new</span> <span class="built_in">Promise</span>(</span><br><span class="line">    resolve =&gt; resolve(f())</span><br><span class="line">  )</span><br><span class="line">)();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'next'</span>);</span><br><span class="line"><span class="comment">// now</span></span><br><span class="line"><span class="comment">// next</span></span><br></pre></td></tr></table></figure><p>上面代码也是使用立即执行的匿名函数，执行new Promise()。这种情况下，同步函数也是同步执行的。</p><p>鉴于这是一个很常见的需求，所以现在有一个提案，提供Promise.try方法替代上面的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> f = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'now'</span>);</span><br><span class="line"><span class="built_in">Promise</span>.try(f);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'next'</span>);</span><br><span class="line"><span class="comment">// now</span></span><br><span class="line"><span class="comment">// next</span></span><br></pre></td></tr></table></figure><p>例题5, 6 来自<a href="https://juejin.im/post/5b7057b251882561381e69bf" target="_blank" rel="noopener">浅析setTimeout与Promise</a>：</p><h3 id="例题5">例题5</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Before resolve"</span>);</span><br><span class="line">    resolve(<span class="number">1</span>);</span><br><span class="line">&#125;)</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"will be executed at the top of the next Event Loop"</span>);</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"p1 fulfilled"</span>);</span><br><span class="line">&#125;)</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"will be executed at the bottom of the next Event Loop"</span>);</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Before resolve</span><br><span class="line">p1 fulfilled</span><br><span class="line">will be executed at the top of the next Event Loop</span><br><span class="line">will be executed at the bottom of the next Event Loop</span><br></pre></td></tr></table></figure><blockquote><ol><li>开始执行JavaScript脚本，将任务JavaScript Run入栈macroTask队列；</li><li>同步resolvePromise后；</li><li>入栈第一个setTimeout任务进入macroTask队列</li><li>入栈Proimse.then任务进入microTask队列；</li><li>入栈第二个setTimeout任务进入macroTask队列；</li><li>同步执行代码完毕，退出第一个macroTask，即JavaScript Run;  输出 Before resolve</li><li>执行清空microTask；输出 p1 fulfilled</li><li>执行下一个macroTask；输出 will be executed at the top of the next Event Loop<br>will be executed at the bottom of the next Event Loop</li></ol></blockquote><h3 id="例题6">例题6</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"will be executed at the top of the next Event Loop"</span>)</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; resolve(<span class="number">1</span>); &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"will be executed at the bottom of the next Event Loop"</span>)</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>)</span>&#123;</span><br><span class="line">        p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">           <span class="built_in">console</span>.log(<span class="string">"promise then - "</span> + j)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;)(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// will be executed at the top of the next Event Loop</span></span><br><span class="line"><span class="comment">// promise then - 0</span></span><br><span class="line"><span class="comment">// promise then - 1</span></span><br><span class="line"><span class="comment">// promise then - 2</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// promise then - 99</span></span><br><span class="line"><span class="comment">// will be executed at the bottom of the next Event Loop</span></span><br></pre></td></tr></table></figure><h3 id="例题7">例题7</h3><p>来源： <a href="https://www.zhihu.com/question/36972010" target="_blank" rel="noopener">Promise的队列与setTimeout的队列有何关联？</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="number">4</span>)&#125;,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">var</span> i=<span class="number">0</span> ; i&lt;<span class="number">10000</span> ; i++ )&#123;</span><br><span class="line">        i==<span class="number">9999</span> &amp;&amp; resolve()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">5</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//1,2,3,5,4</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>首先同步执行完所有代码，其间注册了三个setTimeout异步任务，100个Promise异步任务；</li><li>然后检查MacroTask队列，取第一个到期的MacroTask，执行输出will be executed at the top of the next Event Loop;</li><li>然后检查MicroTask队列，发现没有到期的MicroTask，进入第4步；</li><li>再次检查MacroTask，执行第二个setTimeout处理函数，resolve Promise；</li><li>然后检查MicroTask队列，发现Promise已解决，其异步处理函数均可执行，依次执行，输出promise then - 0 至promise then - 99；</li><li>最后再次检查MacroTask队列，执行输出will be executed at the bottom of the next Event Loop</li><li>交替往复检查两个异步任务队列，直至执行完毕；</li></ol><h2 id="reference-links">Reference Links</h2><ul><li><a href="https://juejin.im/post/5b7057b251882561381e69bf" target="_blank" rel="noopener">浅析setTimeout与Promise</a></li><li><a href="https://juejin.im/post/5b7057b251882561381e69bf" target="_blank" rel="noopener">What is the relationship between event loop and Promise [stackoverflow]</a></li><li><a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="noopener">ES6 Book </a></li><li><a href="https://www.zhihu.com/question/36972010" target="_blank" rel="noopener">Promise的队列与setTimeout的队列有何关联？[知乎]</a></li><li><a href="https://blog.risingstack.com/writing-a-javascript-framework-execution-timing-beyond-settimeout" target="_blank" rel="noopener">Writing a JavaScript framework - Execution timing, beyond setTimeout</a></li><li><a href="https://github.com/deenjohn/NodeRevision/blob/master/6-Concurrency%20model%20and%20event%20loop%20-part%20B.md" target="_blank" rel="noopener">6-Concurrency model and event loop -part B</a></li><li><a href="https://stackoverflow.com/questions/34753342/microtasks-vs-events-and-how-to-define-what-as-which" target="_blank" rel="noopener">Microtasks vs Events and how to define what as which?</a></li><li><a href="https://medium.com/@jitubutwal144/javascript-how-is-callback-execution-strategy-for-promises-different-than-dom-events-callback-73c0e9e203b1" target="_blank" rel="noopener">JavaScript: How is callback execution strategy for promises different than DOM events callback?</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;了解这个，就得了解JavaScript异步编程，了解任务队列才能知其根本。&lt;/p&gt;
&lt;p&gt;一个事件循环（event loop）+多个任务队列（task queue）&lt;/p&gt;
&lt;h2 id=&quot;事件循环-event-loop&quot;&gt;事件循环（event loop）&lt;/h2&gt;
&lt;h2
      
    
    </summary>
    
      <category term="TECH" scheme="https://catherineliyuankun.github.io/categories/TECH/"/>
    
      <category term="FrontEnd" scheme="https://catherineliyuankun.github.io/categories/TECH/FrontEnd/"/>
    
      <category term="JS" scheme="https://catherineliyuankun.github.io/categories/TECH/FrontEnd/JS/"/>
    
    
      <category term="Promise" scheme="https://catherineliyuankun.github.io/tags/Promise/"/>
    
      <category term="TODO" scheme="https://catherineliyuankun.github.io/tags/TODO/"/>
    
  </entry>
  
  <entry>
    <title>Browser Caching</title>
    <link href="https://catherineliyuankun.github.io/Browser-Caching.html"/>
    <id>https://catherineliyuankun.github.io/Browser-Caching.html</id>
    <published>2019-10-28T15:29:53.000Z</published>
    <updated>2019-10-30T08:57:06.803Z</updated>
    
    <content type="html"><![CDATA[<h1 id="reference-links">Reference Links:</h1><ul><li><a href="https://github.com/amandakelake/blog/issues/43" target="_blank" rel="noopener">缓存（一）——缓存总览：从性能优化的角度看缓存 #43</a></li><li><a href="http://jixianqianduan.com/frontend-javascript/2015/12/28/nine-browser-cache-methods.html" target="_blank" rel="noopener">九种浏览器端缓存机制知多少</a></li><li><a href="https://segmentfault.com/a/1190000004132566#articleHeader6" target="_blank" rel="noopener">H5 缓存机制浅析 - 移动端 Web 加载性能优化</a></li></ul><h2 id="indexeddb">IndexedDB</h2><ul><li><a href="https://lavas-project.github.io/pwa-book/chapter03/5-indexeddb.html" target="_blank" rel="noopener">《PWA 应用实战》- IndexedDB</a></li><li><a href="https://lavas.baidu.com/pwa/offline-and-cache-loading/web-storage/indexeddb-best-practices-app-state" target="_blank" rel="noopener">利用 indexedDB 保持应用状态的最佳实践</a></li><li><a href="https://developers.google.com/web/ilt/pwa/working-with-indexeddb" target="_blank" rel="noopener">Progressive Web Apps Training - Working with IndexedDB</a></li><li><a href="https://www.w3.org/TR/IndexedDB/" target="_blank" rel="noopener">Indexed Database API 2.0 from W3C</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Using_IndexedDB" target="_blank" rel="noopener">Using IndexedDB MDN</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;reference-links&quot;&gt;Reference Links:&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/amandakelake/blog/issues/43&quot; target=&quot;_blank&quot; rel=&quot;noopen
      
    
    </summary>
    
      <category term="TECH" scheme="https://catherineliyuankun.github.io/categories/TECH/"/>
    
      <category term="FrontEnd" scheme="https://catherineliyuankun.github.io/categories/TECH/FrontEnd/"/>
    
      <category term="Browser Caching" scheme="https://catherineliyuankun.github.io/categories/TECH/FrontEnd/Browser-Caching/"/>
    
    
      <category term="cache" scheme="https://catherineliyuankun.github.io/tags/cache/"/>
    
  </entry>
  
  <entry>
    <title>IndexedDB-delete whole database by javaScript</title>
    <link href="https://catherineliyuankun.github.io/IndexedDB-delete-whole-database-by-javaScript.html"/>
    <id>https://catherineliyuankun.github.io/IndexedDB-delete-whole-database-by-javaScript.html</id>
    <published>2019-10-28T13:24:15.000Z</published>
    <updated>2019-11-17T19:07:09.346Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用indexeddb-deletedatabase：">使用<a href="https://developer.mozilla.org/en-US/docs/Web/API/IDBFactory/deleteDatabase" target="_blank" rel="noopener">indexedDB.deleteDatabase</a>：</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> DBDeleteRequest = <span class="built_in">window</span>.indexedDB.deleteDatabase(<span class="string">"toDoList"</span>);</span><br><span class="line"></span><br><span class="line">DBDeleteRequest.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Error deleting database."</span>);</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">DBDeleteRequest.onsuccess = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Database deleted successfully"</span>);</span><br><span class="line">    </span><br><span class="line">  <span class="built_in">console</span>.log(event.result); <span class="comment">// should be undefined</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// you must call db.close() before delete, if you already open. otherwise you will get onblocked event</span></span><br><span class="line">DBDeleteRequest.onblocked = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Couldn't delete database due to the operation being blocked"</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="indexeddb-databases">indexedDB.<a href="developer.mozilla.org/en-US/docs/Web/API/IDBFactory/databases">databases()</a></h1><p>可以使用indexedDB.databases() 得到所有的databases List.<br>如果这个数据库已经open过，在删除数据库前需要调用<a href="https://developer.mozilla.org/en-US/docs/Web/API/IDBDatabase/close" target="_blank" rel="noopener">db.close() </a> 否则onblocked event会触发。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">window</span>.indexedDB.databases()</span><br><span class="line">    .then(<span class="function">(<span class="params">dbs</span>) =&gt;</span> &#123;</span><br><span class="line">        dbs.map(<span class="function"><span class="params">db</span> =&gt;</span> &#123;</span><br><span class="line">            db.close();</span><br><span class="line">            <span class="built_in">window</span>.indexedDB.deleteDatabase(db.name)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;).catch(<span class="built_in">console</span>.error);</span><br></pre></td></tr></table></figure><p>indexedDB.databases() 有一个很大问题就是支持的浏览器太少了。只有Chrome和Opera能很好的支持，IE11, Firefox, Safari都不太支持。</p><p>实例：删除除了此user的所有其他IndexedDB</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Checks IndexedDB for all IndexedDBs and deletes them if the username</span></span><br><span class="line"><span class="comment"> * is not the one provided. Used when changing users after session expires.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @static</span></span><br><span class="line"><span class="comment"> * @param &#123;String&#125; usernameToKeep Current authenticated user</span></span><br><span class="line"><span class="comment"> * @returns</span></span><br><span class="line"><span class="comment"> * @memberof DB</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> purgeIndexedDB(usernameToKeep) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.indexedDB &amp;&amp; <span class="built_in">window</span>.indexedDB.databases) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">window</span>.indexedDB.databases()</span><br><span class="line">      .then(<span class="function">(<span class="params">dbs</span>) =&gt;</span> </span><br><span class="line">          dbs.filter(<span class="function">(<span class="params">db</span>) =&gt;</span> (db.name.includes(<span class="string">'_pouch_'</span>) &amp;&amp; (!usernameToKeep || !db.name.includes(usernameToKeep)))))</span><br><span class="line">      .then(<span class="function">(<span class="params">IndexedDBS</span>) =&gt;</span> </span><br><span class="line">          <span class="built_in">Promise</span>.all(IndexedDBS.map(<span class="function">(<span class="params">IndexedDB</span>) =&gt;</span> <span class="built_in">window</span>.indexedDB.deleteDatabase(IndexedDB.name))))</span><br><span class="line">      .catch(<span class="built_in">console</span>.error);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="reference-links">Reference Links:</h1><ul><li><a href="https://stackoverflow.com/questions/15861630/how-can-i-remove-a-whole-indexeddb-database-from-javascript#" target="_blank" rel="noopener">How can I remove a whole IndexedDB database from JavaScript?</a></li><li><a href="developer.mozilla.org/en-US/docs/Web/API/IDBFactory/databases">indexedDB.databases()</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/IDBFactory/deleteDatabase" target="_blank" rel="noopener">indexedDB.deleteDatabase</a></li><li><a href="https://www.w3.org/TR/IndexedDB/#dom-idbfactory-deletedatabase" target="_blank" rel="noopener">dom-idbfactory-deletedatabase W3C</a></li><li><a href="https://www.w3.org/TR/IndexedDB/#delete-a-database" target="_blank" rel="noopener">5.3. Deleting a database W3C</a></li></ul><h2 id="pouch">Pouch</h2><ul><li><a href="https://github.com/pouchdb/pouchdb" target="_blank" rel="noopener">pouchdb/pouchdb</a></li><li><a href="http://webfuse.cn/2016/09/24/PouchDB%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/" target="_blank" rel="noopener">PouchDB简单入门</a></li><li><a href="http://www.vue5.com/pouchdb/pouchdb_delete_database.html" target="_blank" rel="noopener">学习PouchDB</a></li><li><a href="https://www.w3.org/TR/IndexedDB/#dom-idbfactory-deletedatabase" target="_blank" rel="noopener">dom-idbfactory-deletedatabase W3C</a></li><li><a href="https://www.w3.org/TR/IndexedDB/#delete-a-database" target="_blank" rel="noopener">5.3. Deleting a database W3C</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;使用indexeddb-deletedatabase：&quot;&gt;使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/IDBFactory/deleteDatabase&quot; target=&quot;_blank&quot; 
      
    
    </summary>
    
      <category term="TECH" scheme="https://catherineliyuankun.github.io/categories/TECH/"/>
    
      <category term="FrontEnd" scheme="https://catherineliyuankun.github.io/categories/TECH/FrontEnd/"/>
    
      <category term="Browser Caching" scheme="https://catherineliyuankun.github.io/categories/TECH/FrontEnd/Browser-Caching/"/>
    
      <category term="IndexedDB" scheme="https://catherineliyuankun.github.io/categories/TECH/FrontEnd/Browser-Caching/IndexedDB/"/>
    
    
      <category term="IndexedDB" scheme="https://catherineliyuankun.github.io/tags/IndexedDB/"/>
    
  </entry>
  
  <entry>
    <title>Z-index</title>
    <link href="https://catherineliyuankun.github.io/Z-index.html"/>
    <id>https://catherineliyuankun.github.io/Z-index.html</id>
    <published>2019-10-24T11:48:32.000Z</published>
    <updated>2019-10-29T12:24:43.149Z</updated>
    
    <content type="html"><![CDATA[<h2 id="reference-links">Reference Links</h2><ul><li><a href="https://webdesign.tutsplus.com/zh-hans/articles/what-you-may-not-know-about-the-z-index-property--webdesign-16892" target="_blank" rel="noopener">关于z-index 那些你不知道的事</a></li></ul><!-- - [官方文档中文版：hooks](https://zh-hans.reactjs.org/docs/hooks-intro.html) -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;reference-links&quot;&gt;Reference Links&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://webdesign.tutsplus.com/zh-hans/articles/what-you-may-not-know-about-
      
    
    </summary>
    
      <category term="TECH" scheme="https://catherineliyuankun.github.io/categories/TECH/"/>
    
      <category term="FrontEnd" scheme="https://catherineliyuankun.github.io/categories/TECH/FrontEnd/"/>
    
      <category term="CSS" scheme="https://catherineliyuankun.github.io/categories/TECH/FrontEnd/CSS/"/>
    
    
      <category term="TODO" scheme="https://catherineliyuankun.github.io/tags/TODO/"/>
    
  </entry>
  
  <entry>
    <title>HTTP CORS disable for chrome</title>
    <link href="https://catherineliyuankun.github.io/HTTP-CORS-disable.html"/>
    <id>https://catherineliyuankun.github.io/HTTP-CORS-disable.html</id>
    <published>2019-10-21T13:51:01.000Z</published>
    <updated>2019-11-04T17:04:37.707Z</updated>
    
    <content type="html"><![CDATA[<p>CORS的基本原理请看上一篇：</p><!-- [CORS的基本原理](../../../../2019/10/21/HTTP CORS disable) --><p><a href="../HTTP-CORS.html">CORS的基本原理</a></p><p>简单关闭Chrome的CORS方法:</p><h1 id="macos">MacOS</h1><p>命令行里, 会另外打开一个Chrome窗口：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜   ✗ open -n -a <span class="string">"/Applications/Google Chrome.app/Contents/MacOS/Google Chrome"</span> --args --user-data-dir=<span class="string">"/tmp/chrome_dev_test"</span> --<span class="built_in">disable</span>-web-security</span><br></pre></td></tr></table></figure><blockquote><p>–user-data-dir 参数需要 Chrome 版本 49+ on OSX</p></blockquote><p>如果想访问本地文件（开发目的来使用 AJAX 或 JSON），可以使用flag：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-–allow-<span class="built_in">file</span>-access-<span class="built_in">from</span>-<span class="built_in">files</span></span><br></pre></td></tr></table></figure><h1 id="windows">Windows</h1><p>进入command prompt，进入到Chrome.exe文件夹，执行命令：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chrome<span class="selector-class">.exe</span> --disable-web-security</span><br></pre></td></tr></table></figure><p>这个命令会禁掉CORS，而且可以访问本地文件。</p><h1 id="reference-links">Reference Links:</h1><p><a href="https://stackoverflow.com/questions/3102819/disable-same-origin-policy-in-chrome" target="_blank" rel="noopener">Disable same origin policy in Chrome</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CORS的基本原理请看上一篇：&lt;/p&gt;
&lt;!-- [CORS的基本原理](../../../../2019/10/21/HTTP CORS disable) --&gt;
&lt;p&gt;&lt;a href=&quot;../HTTP-CORS.html&quot;&gt;CORS的基本原理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;简单
      
    
    </summary>
    
      <category term="TECH" scheme="https://catherineliyuankun.github.io/categories/TECH/"/>
    
      <category term="Network" scheme="https://catherineliyuankun.github.io/categories/TECH/Network/"/>
    
      <category term="Servlet/HTTP" scheme="https://catherineliyuankun.github.io/categories/TECH/Network/Servlet-HTTP/"/>
    
    
      <category term="CORS" scheme="https://catherineliyuankun.github.io/tags/CORS/"/>
    
  </entry>
  
  <entry>
    <title>React 16 - Hooks</title>
    <link href="https://catherineliyuankun.github.io/React-16-Hooks.html"/>
    <id>https://catherineliyuankun.github.io/React-16-Hooks.html</id>
    <published>2019-10-21T09:45:22.000Z</published>
    <updated>2019-10-29T12:28:26.919Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hooks-faq">Hooks FAQ</h1><p>觉得<a href="https://zh-hans.reactjs.org/docs/hooks-faq.html" target="_blank" rel="noopener">Hooks FAQ</a>里面回答了很多很实际的疑问。</p><h2 id="生命周期方法要如何对应到-hook？">生命周期方法要如何对应到 Hook？</h2><ul><li><p>constructor：函数组件不需要构造函数。你可以通过调用 useState 来初始化 state。如果计算的代价比较昂贵，你可以传一个函数给 useState。</p></li><li><p>getDerivedStateFromProps：改为 在渲染时 安排一次更新。</p></li><li><p>shouldComponentUpdate：详见 下方 React.memo.</p></li><li><p>render：这是函数组件体本身。</p></li><li><p>componentDidMount, componentDidUpdate, componentWillUnmount：useEffect Hook 可以表达所有这些(包括 不那么 常见 的场景)的组合。</p></li><li><p>componentDidCatch and getDerivedStateFromError：目前还没有这些方法的 Hook 等价写法，但很快会加上。</p></li></ul><h2 id="我该如何使用-hook-进行数据获取？">我该如何使用 Hook 进行数据获取？</h2><p>该 <a href="https://codesandbox.io/s/jvvkoo8pq3" target="_blank" rel="noopener">demo</a> 会帮助你开始理解。欲了解更多，请查阅 <a href="https://www.robinwieruch.de/react-hooks-fetch-data" target="_blank" rel="noopener">react-hooks-fetch-data</a> 来了解如何使用 Hook 进行数据获取。</p><h2 id="reference-links">Reference Links</h2><ul><li><a href="https://react.docschina.org/docs/portals.html" target="_blank" rel="noopener">新一代 React API — React Hooks React Conf 2018 React Today and Tomorrow 重點回顧</a></li><li><a href="https://reactjs.org/docs/hooks-intro.html" target="_blank" rel="noopener">官方文档英文版：hooks-intro</a></li><li><a href="https://zh-hans.reactjs.org/docs/hooks-intro.html" target="_blank" rel="noopener">官方文档中文版：hooks</a></li><li><a href="https://upmostly.com/tutorials/settimeout-in-react-components-using-hooks" target="_blank" rel="noopener">setTimeout in React Components Using Hooks</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;hooks-faq&quot;&gt;Hooks FAQ&lt;/h1&gt;
&lt;p&gt;觉得&lt;a href=&quot;https://zh-hans.reactjs.org/docs/hooks-faq.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hooks FAQ&lt;/a
      
    
    </summary>
    
      <category term="TECH" scheme="https://catherineliyuankun.github.io/categories/TECH/"/>
    
      <category term="FrontEnd" scheme="https://catherineliyuankun.github.io/categories/TECH/FrontEnd/"/>
    
      <category term="React" scheme="https://catherineliyuankun.github.io/categories/TECH/FrontEnd/React/"/>
    
    
      <category term="React 16" scheme="https://catherineliyuankun.github.io/tags/React-16/"/>
    
  </entry>
  
  <entry>
    <title>Github All You should know</title>
    <link href="https://catherineliyuankun.github.io/Github-All-You-should-know.html"/>
    <id>https://catherineliyuankun.github.io/Github-All-You-should-know.html</id>
    <published>2019-10-15T13:33:20.000Z</published>
    <updated>2019-10-15T14:55:53.523Z</updated>
    
    <content type="html"><![CDATA[<h2 id="who-is-assignees">Who is Assignees?</h2><p><a href="https://stackoverflow.com/questions/43617352/" target="_blank" rel="noopener"> What do reviewer and assignee mean in pull request?</a> 里的答案：</p><blockquote><p>For a pull request, you can now &quot;request a review explicitly from collaborators, making it easier to specify who you’d like to review your pull request.&quot;<br>但是Assignees<br>Assignees, on the other hand, “clarify who is working on specific issues and pull requests.”</p></blockquote><blockquote><p>In sum, the difference is whether you’d like to ask someone to work on fixing an issue or contribute to a pull request (<strong>assignee</strong>), versus asking someone to quality check your work (<strong>reviewer</strong>).<br>Sources:<br><a href="https://github.com/blog/2291-introducing-review-requests" target="_blank" rel="noopener">https://github.com/blog/2291-introducing-review-requests</a><br><a href="https://help.github.com/articles/assigning-issues-and-pull-requests-to-other-github-users/" target="_blank" rel="noopener">https://help.github.com/articles/assigning-issues-and-pull-requests-to-other-github-users/</a></p></blockquote><p><a href="https://stackoverflow.com/questions/41087206/on-github-whats-the-difference-between-reviewer-and-assignee" target="_blank" rel="noopener"> On GitHub, what’s the difference between reviewer and assignee?</a>里的答案：</p><blockquote><p>After discussing with several OSS maintainers, reviewers is defined as what the word supposed to be: to review (someone’s code) and “assignee” has a looser definiton explained below.</p></blockquote><blockquote><p>For “reviewer”: someone you want to review the code. Not necessarily the person responsible for that area or responsible for merging the commit. Can be someone who worked on that chunk of code before, as GitHub auto-suggests.</p></blockquote><blockquote><p>For “assignee”: up to the project’s team/maintainer what it means and there’s no strict definition. It can be the PR opener, or someone responsible for that area (who is going to accept the PR after the review is done or just close it). It’s not up to GitHub to define what it is leaving it open for project maintainers what fits best for their project.</p></blockquote><blockquote><p>Previous answer:<br>Ok I’ll go ahead and answer my own question.<br>For PR of users with write-access: the Assignee would be the same person who opened the PR, and reviewer would replace the old assignee function (reviewing code), being this one someone of assignee choice.<br>For PR of users without write-access (outside contributors): Someone with write-access would assign herself (or other write-priviledge member), to review the PR (Reviewer). Assignee is blank.<br>For unfinished PR from outside contributors: the write-access member would take the unfinished work and assign for her. She will be responsible for finishing the task, being the Assignee. Since the main reason of PRs is reviewing changes, she would select some other people to review the changes.</p></blockquote><p>总结下：<br>reviewer: 一般很好理解，就是来review你代码的人。可以是原来改过这段代码的人，负责这块代码的人或是负责merge代码的人。<br>Assignees: 其实，没有严格定义，可以具体看项目组怎么用这个选项。一般分两个场景</p><ol><li>Pull request：创建pull request的人（这种在另一个组的时候用过，如果你是创建的人，可以指定自己），或者是负责merge代码的人（我们组是这么用的），或者就是当review/colse PR完后accept PR的人.</li><li>Issue：当你收到一个issue（通常不是你建的issue）， 你需要指定人来fix这个issue，就可以在Assignees填。</li></ol><h1 id="reference-links">Reference Links:</h1><ul><li><a href="https://stackoverflow.com/questions/41087206/on-github-whats-the-difference-between-reviewer-and-assignee" target="_blank" rel="noopener"> On GitHub, what’s the difference between reviewer and assignee?</a></li><li><a href="https://stackoverflow.com/questions/43617352/what-do-reviewer-and-assignee-mean-in-pull-request?noredirect=1&amp;lq=1" target="_blank" rel="noopener"> What do reviewer and assignee mean in pull request? [duplicate]</a></li><li><a href="http://www.ruanyifeng.com/blog/2017/08/issue.html" target="_blank" rel="noopener"> 如何使用 Issue 管理软件项目？</a></li><li><a href="https://tech.hahow.in/%E5%AE%8C%E5%96%84-github-flow-%E6%9C%80%E5%BE%8C%E4%B8%80%E5%93%A9%E8%B7%AF-probot-d1cda24e4455" target="_blank" rel="noopener"> 完善 GitHub Flow 最後一哩路 — Probot -Assignees 下拉選單</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;who-is-assignees&quot;&gt;Who is Assignees?&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/43617352/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt; 
      
    
    </summary>
    
      <category term="TECH" scheme="https://catherineliyuankun.github.io/categories/TECH/"/>
    
      <category term="Tools" scheme="https://catherineliyuankun.github.io/categories/TECH/Tools/"/>
    
    
      <category term="git" scheme="https://catherineliyuankun.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Responsive web - Flexbox</title>
    <link href="https://catherineliyuankun.github.io/Responsive-web-Flexbox.html"/>
    <id>https://catherineliyuankun.github.io/Responsive-web-Flexbox.html</id>
    <published>2019-10-15T11:18:56.000Z</published>
    <updated>2019-10-15T14:55:36.385Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础教程：">基础教程：</h2><ul><li><a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/" target="_blank" rel="noopener"> 官方文档 A Complete Guide to Flexbox</a></li><li><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener"> 阮一峰 Flex 布局教程：语法篇</a></li></ul><p>但是看完还是有些不懂的地方：</p><h2 id="flex-basis-具体的含义">Flex Basis 具体的含义:</h2><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-basis" target="_blank" rel="noopener"> flex-basis MDN</a><br>以及和width的区别：</li><li><a href="https://www.jianshu.com/p/17b1b445ecd4" target="_blank" rel="noopener"> Flex Basis与Width的区别</a></li><li><a href="https://gedd.ski/post/the-difference-between-width-and-flex-basis/" target="_blank" rel="noopener"> The Difference Between Width and Flex Basis</a></li></ul><h2 id="flex-grow-flex-shrink-flex-basis-是怎么此消彼长的">flex-grow、flex-shrink、flex-basis 是怎么此消彼长的</h2><p>如果分配剩余空间？</p><ul><li><a href="https://zhoon.github.io/css3/2014/08/23/flex.html" target="_blank" rel="noopener"> 深入理解css3中的flex-grow、flex-shrink、flex-basis</a></li></ul><h2 id="小实践：">小实践：</h2><p>Code Pen - Flexbox Form:<br><a href="https://codepen.io/catherineliyuankun/pen/dyyMKzW" target="_blank" rel="noopener">Flexbox Form</a><br>有个困惑， 比如.wrapper 的width只有比如100px; 但是lable/span又不想换行，这时lable的flex-grow:1,.date的flex-grow:3. 也就是比例是1：3，lable就会被截断。 当然如果flex-grow:1都为1，input和lable同比例缩小，会解决。<br>但是在lable不长的情况下，不想让lable 和 input 部分的比例为1：1.</p><p>当然通过 media query 来实现修改flex的值，但是如果我想以.wrapper的宽度来修改flex-grow的值要怎么做呢？或者以lable的长度来修改.date的flex-grow的值？（lable长的时候，lable: .date = 1：1，lable短的时候，1：3）?</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">media</span> screen and (min-width: <span class="number">768px</span>) &#123;</span><br><span class="line">   <span class="selector-class">.form-row</span> &gt; <span class="selector-class">.date</span> &#123;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">3</span>;  </span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> @<span class="keyword">media</span> screen and (min-width: <span class="number">992px</span>) &#123;</span><br><span class="line">   <span class="selector-class">.form-row</span> &gt; <span class="selector-class">.date</span> &#123;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">4</span>;  </span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.form-row</span> &gt; <span class="selector-tag">span</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">padding</span>: .<span class="number">5em</span> <span class="number">1em</span> .<span class="number">5em</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">white-space</span>: nowrap;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.form-row</span> &gt; <span class="selector-class">.date</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">align-items</span>: baseline;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="reference-links">Reference Links:</h1><ul><li><a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/" target="_blank" rel="noopener"> 官方文档 A Complete Guide to Flexbox</a></li><li><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener"> 阮一峰 Flex 布局教程：语法篇</a></li><li><a href="https://www.quackit.com/css/flexbox/tutorial/align_form_elements_with_flexbox.cfm" target="_blank" rel="noopener"> How to Align Form Elements with Flexbox</a></li><li><a href="https://www.jianshu.com/p/17b1b445ecd4" target="_blank" rel="noopener"> Flex Basis与Width的区别</a></li><li><a href="https://gedd.ski/post/the-difference-between-width-and-flex-basis/" target="_blank" rel="noopener"> The Difference Between Width and Flex Basis</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基础教程：&quot;&gt;基础教程：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://css-tricks.com/snippets/css/a-guide-to-flexbox/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt; 官方文档 A 
      
    
    </summary>
    
      <category term="TECH" scheme="https://catherineliyuankun.github.io/categories/TECH/"/>
    
      <category term="FrontEnd" scheme="https://catherineliyuankun.github.io/categories/TECH/FrontEnd/"/>
    
      <category term="CSS" scheme="https://catherineliyuankun.github.io/categories/TECH/FrontEnd/CSS/"/>
    
      <category term="Flexbox" scheme="https://catherineliyuankun.github.io/categories/TECH/FrontEnd/CSS/Flexbox/"/>
    
    
      <category term="Flexbox" scheme="https://catherineliyuankun.github.io/tags/Flexbox/"/>
    
  </entry>
  
  <entry>
    <title>ES6-Promise</title>
    <link href="https://catherineliyuankun.github.io/ES6-Promise.html"/>
    <id>https://catherineliyuankun.github.io/ES6-Promise.html</id>
    <published>2019-10-13T12:05:41.000Z</published>
    <updated>2019-10-29T12:45:12.657Z</updated>
    
    <content type="html"><![CDATA[<h1 id="promise">Promise</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ... some code</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)&#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。</p><p>resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p><p>Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// failure</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。</p><h2 id="promise-prototype-then">Promise.prototype.then()</h2><p>then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数</p><h2 id="promise-prototype-catch">Promise.prototype.catch()</h2><p>.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数。</p><h2 id="promise-prototype-finally">Promise.prototype.finally()</h2><p>finally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line">promise</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// success</span></span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// error</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">promise</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123; <span class="comment">//cb</span></span><br><span class="line">    <span class="comment">// success</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// error</span></span><br><span class="line">    <span class="comment">//.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数。</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .finally(</span><br><span class="line">      <span class="comment">//不管 Promise 对象最后状态如何，都会执行的操作</span></span><br><span class="line">      <span class="comment">//与状态无关的，不依赖于 Promise 的执行结果</span></span><br><span class="line">  );</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout start'</span>);</span><br><span class="line">    setTimeout(resolve, ms, <span class="string">'done'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout end'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">timeout(<span class="number">100</span>).then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// setTimeout start</span></span><br><span class="line"><span class="comment">// setTimeout end</span></span><br><span class="line"><span class="comment">// done</span></span><br></pre></td></tr></table></figure><h1 id="处理多个promise">处理多个promise</h1><h2 id="promise-all">Promise.all()</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.all([p1, p2, p3]);</span><br></pre></td></tr></table></figure><p>return all resolved</p><p>p的状态由p1、p2、p3决定，分成两种情况。<br>（1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。</p><p>（2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。</p><h2 id="promise-race">Promise.race()</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.race([p1, p2, p3]);</span><br></pre></td></tr></table></figure><p>return first result</p><p>只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。</p><h2 id="promise-allsettled">Promise.allSettled()</h2><p>return all end</p><p>只有等到所有这些参数实例都返回结果，不管是fulfilled还是rejected，包装实例才会结束。该方法由 ES2020 引入。<br>我们不关心异步操作的结果，只关心这些操作有没有结束。这时，Promise.allSettled()方法就很有用。如果没有这个方法，想要确保所有操作都结束，就很麻烦。Promise.all()方法无法做到这一点。</p><h2 id="promise-any">Promise.any()</h2><p>return any resolved</p><p>只要参数实例有一个变成fulfilled状态，包装实例就会变成fulfilled状态；如果所有参数实例都变成rejected状态，包装实例就会变成rejected状态。该方法目前是一个第三阶段的提案 。</p><h1 id="返回一个新的-promise-实例">返回一个新的 Promise 实例</h1><h2 id="promise-resolve">Promise.resolve()</h2><p>需要将现有对象转为 Promise 对象。Promise.resolve()在本轮“事件循环”结束时执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'foo'</span>)</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(<span class="string">'foo'</span>))</span><br></pre></td></tr></table></figure><h2 id="promise-reject">Promise.reject()</h2><p>Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected。<br>注意，Promise.reject()方法的参数，会原封不动地作为reject的理由，变成后续方法的参数。这一点与Promise.resolve方法不一致。</p><h2 id="promise-try">Promise.try()</h2><p>实际开发中，经常遇到一种情况：不知道或者不想区分，函数f是同步函数还是异步操作，但是想用 Promise 来处理它。因为这样就可以不管f是否包含异步操作，都用then方法指定下一步流程，用catch方法处理f抛出的错误。一般就会采用下面的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().then(f)</span><br></pre></td></tr></table></figure><p>上面的写法有一个缺点，就是如果f是同步函数，那么它会在本轮事件循环的末尾执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> f = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'now'</span>);</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(f);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'next'</span>);</span><br><span class="line"><span class="comment">// next</span></span><br><span class="line"><span class="comment">// now</span></span><br></pre></td></tr></table></figure><p>上面代码中，函数f是同步的，但是用 Promise 包装了以后，就变成异步执行了。</p><p>那么有没有一种方法，让同步函数同步执行，异步函数异步执行，并且让它们具有统一的 API 呢？回答是可以的，并且还有两种写法。</p><h3 id="第一种写法是用async函数来写">第一种写法是用async函数来写。</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> f = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'now'</span>);</span><br><span class="line">(<span class="keyword">async</span> () =&gt; f())();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'next'</span>);</span><br><span class="line"><span class="comment">// now</span></span><br><span class="line"><span class="comment">// next</span></span><br></pre></td></tr></table></figure><p>上面代码中，第二行是一个立即执行的匿名函数，会立即执行里面的async函数，因此如果f是同步的，就会得到同步的结果；如果f是异步的，就可以用then指定下一步，就像下面的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; f())()</span><br><span class="line">.then(...)</span><br></pre></td></tr></table></figure><p>需要注意的是，async () =&gt; f()会吃掉f()抛出的错误。所以，如果想捕获错误，要使用promise.catch方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; f())()</span><br><span class="line">.then(...)</span><br><span class="line">.catch(...)</span><br></pre></td></tr></table></figure><h3 id="第二种写法是使用new-promise">第二种写法是使用new Promise()。</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> f = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'now'</span>);</span><br><span class="line">(</span><br><span class="line">  () =&gt; <span class="keyword">new</span> <span class="built_in">Promise</span>(</span><br><span class="line">    resolve =&gt; resolve(f())</span><br><span class="line">  )</span><br><span class="line">)();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'next'</span>);</span><br><span class="line"><span class="comment">// now</span></span><br><span class="line"><span class="comment">// next</span></span><br></pre></td></tr></table></figure><p>上面代码也是使用立即执行的匿名函数，执行new Promise()。这种情况下，同步函数也是同步执行的。</p><p>鉴于这是一个很常见的需求，所以现在有一个提案，提供Promise.try方法替代上面的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> f = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'now'</span>);</span><br><span class="line"><span class="built_in">Promise</span>.try(f);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'next'</span>);</span><br><span class="line"><span class="comment">// now</span></span><br><span class="line"><span class="comment">// next</span></span><br></pre></td></tr></table></figure><p>事实上，Promise.try存在已久，Promise 库Bluebird、Q和when，早就提供了这个方法。</p><p>由于Promise.try为所有操作提供了统一的处理机制，所以如果想用then方法管理流程，最好都用Promise.try包装一下。这样有许多好处，其中一点就是可以更好地管理异常。</p><p>function getUsername(userId) {<br>return database.users.get({id: userId})<br>.then(function(user) {<br>return <a href="http://user.name" target="_blank" rel="noopener">user.name</a>;<br>});<br>}<br>上面代码中，database.users.get()返回一个 Promise 对象，如果抛出异步错误，可以用catch方法捕获，就像下面这样写。</p><p>database.users.get({id: userId})<br>.then(…)<br>.catch(…)<br>但是database.users.get()可能还会抛出同步错误（比如数据库连接错误，具体要看实现方法），这时你就不得不用try…catch去捕获。</p><p>try {<br>database.users.get({id: userId})<br>.then(…)<br>.catch(…)<br>} catch (e) {<br>// …<br>}<br>上面这样的写法就很笨拙了，这时就可以统一用promise.catch()捕获所有同步和异步的错误。</p><p>Promise.try(() =&gt; database.users.get({id: userId}))<br>.then(…)<br>.catch(…)<br>事实上，Promise.try就是模拟try代码块，就像promise.catch模拟的是catch代码块。</p><h1 id="reference-links">Reference Links:</h1><ul><li><a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="noopener">ES6 Book </a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;promise&quot;&gt;Promise&lt;/h1&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span c
      
    
    </summary>
    
      <category term="TECH" scheme="https://catherineliyuankun.github.io/categories/TECH/"/>
    
      <category term="FrontEnd" scheme="https://catherineliyuankun.github.io/categories/TECH/FrontEnd/"/>
    
      <category term="ES6" scheme="https://catherineliyuankun.github.io/categories/TECH/FrontEnd/ES6/"/>
    
    
      <category term="Promise" scheme="https://catherineliyuankun.github.io/tags/Promise/"/>
    
  </entry>
  
  <entry>
    <title>HTTP CORS</title>
    <link href="https://catherineliyuankun.github.io/HTTP-CORS.html"/>
    <id>https://catherineliyuankun.github.io/HTTP-CORS.html</id>
    <published>2019-10-12T13:51:01.000Z</published>
    <updated>2019-10-22T08:33:35.042Z</updated>
    
    <content type="html"><![CDATA[<p>Reference Links里的两篇文章讲述的已经很详细了。简单列一下：</p><h1 id="0-cors">0 CORS</h1><p>简单说就是从A网址（origin (domain) ）向B网址发送请求，称为跨域。从A网址向A网址发送请求就是，同域。</p><h2 id="a-与-b-什么不同？">A 与 B 什么不同？</h2><p>不同的域、协议或端口。</p><p><img src="https://mdn.mozillademos.org/files/14295/CORS_principle.png" alt="CORS"></p><h1 id="1-简单请求-simple-request">1. 简单请求（simple request）</h1><blockquote><p>（1) 请求方法是以下三种方法之一：</p><ul><li>HEAD</li><li>GET</li><li>POST</li></ul></blockquote><blockquote><p>（2）HTTP的头信息不超出以下几种字段：</p><ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Last-Event-ID</li><li>Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/ plain</li><li>DPR</li><li>Downlink</li><li>Save-Data</li><li>Viewport-Width</li><li>Width</li></ul></blockquote><blockquote><p>（3）请求中的任意XMLHttpRequestUpload 对象均没有注册任何事件监听器；XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问。<br>（4）请求中没有使用 ReadableStream 对象。</p></blockquote><p>假如站点 <a href="http://Server-b.com" target="_blank" rel="noopener">http://Server-b.com</a> 的网页应用想要访问 <a href="http://bar.other" target="_blank" rel="noopener">http://bar.other</a> 的资源。<br>A向B请求，那么A就是Orign.<br><img src="https://mdn.mozillademos.org/files/14293/simple_req.png" alt="简单请求（simple request）"></p><h1 id="2-非简单请求-not-so-simple-request">2. 非简单请求（not-so-simple request）</h1><blockquote><p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。</p></blockquote><blockquote><p>（1) 使用了下面任一 HTTP 方法：</p><ul><li>PUT</li><li>DELETE</li><li>CONNECT</li><li>OPTIONS</li><li>TRACE</li><li>PATCH</li></ul></blockquote><blockquote><p>（2) 人为设置了对 CORS 安全的首部字段集合之外的其他首部字段。该集合为：</p><ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Content-Type (需要注意额外的限制)</li><li>DPR</li><li>Downlink</li><li>Save-Data</li><li>Viewport-Width</li><li>Width</li></ul></blockquote><blockquote><p>（3) Content-Type 的值不属于下列之一:</p><ul><li>application/x-www-form-urlencoded</li><li>multipart/form-data</li><li>text/plain</li></ul></blockquote><blockquote><p>（4) 请求中的XMLHttpRequestUpload 对象注册了任意多个事件监听器。</p></blockquote><blockquote><p>（5) 请求中使用了ReadableStream对象。</p></blockquote><p>假如站点 <a href="http://foo.example" target="_blank" rel="noopener">http://foo.example</a> 的网页应用想要访问 <a href="http://bar.other" target="_blank" rel="noopener">http://bar.other</a> 的资源。</p><p><img src="https://mdn.mozillademos.org/files/16753/preflight_correct.png" alt="预检请求+真实请求"></p><h2 id="2-1-预检请求-option">2.1 预检请求 OPTION</h2><p>OPTION 由于跨域请求被拦截，返回503：<br><img src="https://github.com/CatherineLiyuankun/PictureBed/raw/master/blog/post/HTTP-CORS/OPTION%20503.png" alt="OPTION 503"></p><p>Error:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Access to XMLHttpRequest at <span class="string">'https://B'</span> <span class="keyword">from</span> origin <span class="string">'https://A'</span> </span><br><span class="line">has been blocked by CORS policy: </span><br><span class="line">Response to preflight request doesn<span class="string">'t pass access control check: It does not have HTTP ok status.</span></span><br></pre></td></tr></table></figure><h2 id="2-2-真实请求">2.2 真实请求</h2><h1 id="3-附带身份凭证的请求">3 附带身份凭证的请求</h1><blockquote><p>它其实必然是1 简单请求（simple request）2. 非简单请求（not-so-simple request）的其中一种。只是多加了对Cookie和HTTP认证信息的判断。<br>CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定Access-Control-Allow-Credentials字段。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Credentials: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>另一方面，开发者必须在AJAX请求中打开withCredentials属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。</p><p>但是，如果省略withCredentials设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭withCredentials。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.withCredentials = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>A向B请求。<code>需要注意的是，如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页A一致的域名。</code>否则报错：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Access to XMLHttpRequest at <span class="string">'https://B'</span> <span class="keyword">from</span> origin <span class="string">'https://A'</span> has been blocked by CORS policy: </span><br><span class="line">The value <span class="keyword">of</span> the <span class="string">'Access-Control-Allow-Origin'</span> header <span class="keyword">in</span> the response must not be </span><br><span class="line">the wildcard <span class="string">'*'</span> when the request<span class="string">'s credentials mode is '</span>include<span class="string">'.</span></span><br><span class="line"><span class="string">The credentials mode of requests initiated by the XMLHttpRequest </span></span><br><span class="line"><span class="string">is controlled by the withCredentials attribute.</span></span><br></pre></td></tr></table></figure><p>同时，Cookie依然遵循同源政策，只有用服务器域名B设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页A代码中的document.cookie也无法读取服务器域名下的Cookie。</p><p><img src="https://mdn.mozillademos.org/files/14291/cred-req.png" alt="附带身份凭证的请求"></p><h1 id="总结流程">总结流程</h1><p>来源：<a href="https://github.com/amandakelake/blog/issues/62" target="_blank" rel="noopener">CORS 简单请求+预检请求（彻底理解跨域）</a><br><img src="https://user-images.githubusercontent.com/25027560/50205881-c409b080-03a4-11e9-8a57-a2a6d0e1d879.png" alt="CORS请求流程"></p><h1 id="reference-links">Reference Links:</h1><p><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">跨域资源共享 CORS 详解</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="noopener">HTTP访问控制（CORS）</a><br><a href="https://github.com/amandakelake/blog/issues/62" target="_blank" rel="noopener">CORS 简单请求+预检请求（彻底理解跨域）</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Reference Links里的两篇文章讲述的已经很详细了。简单列一下：&lt;/p&gt;
&lt;h1 id=&quot;0-cors&quot;&gt;0 CORS&lt;/h1&gt;
&lt;p&gt;简单说就是从A网址（origin (domain) ）向B网址发送请求，称为跨域。从A网址向A网址发送请求就是，同域。&lt;/p&gt;

      
    
    </summary>
    
      <category term="TECH" scheme="https://catherineliyuankun.github.io/categories/TECH/"/>
    
      <category term="Network" scheme="https://catherineliyuankun.github.io/categories/TECH/Network/"/>
    
      <category term="Servlet/HTTP" scheme="https://catherineliyuankun.github.io/categories/TECH/Network/Servlet-HTTP/"/>
    
    
      <category term="CORS" scheme="https://catherineliyuankun.github.io/tags/CORS/"/>
    
  </entry>
  
  <entry>
    <title>React all articles</title>
    <link href="https://catherineliyuankun.github.io/React-all-articles.html"/>
    <id>https://catherineliyuankun.github.io/React-all-articles.html</id>
    <published>2019-09-09T09:44:38.000Z</published>
    <updated>2019-11-04T17:06:57.538Z</updated>
    
    <content type="html"><![CDATA[<p><a href="../React-16-New-feature-Summary-Links.html">React 16 new feature</a><br><a href="https://juejin.im/post/5c7df2e7f265da2d8a55d49d" target="_blank" rel="noopener">【React深入】React事件机制</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;../React-16-New-feature-Summary-Links.html&quot;&gt;React 16 new feature&lt;/a&gt;&lt;br&gt;
&lt;a href=&quot;https://juejin.im/post/5c7df2e7f265da2d8a55d49
      
    
    </summary>
    
      <category term="TECH" scheme="https://catherineliyuankun.github.io/categories/TECH/"/>
    
      <category term="FrontEnd" scheme="https://catherineliyuankun.github.io/categories/TECH/FrontEnd/"/>
    
      <category term="React" scheme="https://catherineliyuankun.github.io/categories/TECH/FrontEnd/React/"/>
    
    
      <category term="Links" scheme="https://catherineliyuankun.github.io/tags/Links/"/>
    
  </entry>
  
  <entry>
    <title>Markdown表格中单元格合并</title>
    <link href="https://catherineliyuankun.github.io/Markdown%E8%A1%A8%E6%A0%BC%E4%B8%AD%E5%8D%95%E5%85%83%E6%A0%BC%E5%90%88%E5%B9%B6.html"/>
    <id>https://catherineliyuankun.github.io/Markdown表格中单元格合并.html</id>
    <published>2019-09-03T17:56:29.000Z</published>
    <updated>2019-09-03T12:01:02.508Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://3nice.cc/2018/10/01/markdowntable/" target="_blank" rel="noopener">解决在Markdown中的表格单元格合并的问题</a></li><li><a href="https://www.zhihu.com/question/50267650" target="_blank" rel="noopener">markdown的表格语法能合并单元格吗？</a><br><a href="https://blog.csdn.net/loongshawn/article/details/72829090" target="_blank" rel="noopener">Markdown表格之合并单元格效果</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://3nice.cc/2018/10/01/markdowntable/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;解决在Markdown中的表格单元格合并的问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;h
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>React 16 - DOM Attributes</title>
    <link href="https://catherineliyuankun.github.io/React-16-DOM-Attributes.html"/>
    <id>https://catherineliyuankun.github.io/React-16-DOM-Attributes.html</id>
    <published>2019-09-03T09:08:53.000Z</published>
    <updated>2019-09-03T06:29:26.309Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="TECH" scheme="https://catherineliyuankun.github.io/categories/TECH/"/>
    
      <category term="FrontEnd" scheme="https://catherineliyuankun.github.io/categories/TECH/FrontEnd/"/>
    
      <category term="React" scheme="https://catherineliyuankun.github.io/categories/TECH/FrontEnd/React/"/>
    
    
      <category term="React 16" scheme="https://catherineliyuankun.github.io/tags/React-16/"/>
    
  </entry>
  
  <entry>
    <title>React 16 - Portal</title>
    <link href="https://catherineliyuankun.github.io/React-16-Portal.html"/>
    <id>https://catherineliyuankun.github.io/React-16-Portal.html</id>
    <published>2019-09-03T09:07:35.000Z</published>
    <updated>2019-09-09T07:56:15.189Z</updated>
    
    <content type="html"><![CDATA[<p>转<a href="https://zhuanlan.zhihu.com/p/29880992" target="_blank" rel="noopener">传送门：React Portal</a>， 在这个基础上做了小的修改。</p><p>似乎所有说React Portal都直接用Portal这个单词，没听过这词的朋友可能觉得不知所云，其实，Portal可以有一个很形象的翻译——“传送门”。</p><h2 id="什么是传送门？">什么是传送门？</h2><p>曾经有一款游戏就叫做Portal，玩家手上一杆很厉害很科幻的枪，朝墙上开一枪，就可以开出两个“传送门”，人钻进这个传送门，可以从另一个传送门里走出来，也就是说，两个不同位置的传送门之间形成了对接。</p><p><img src="https://pic4.zhimg.com/80/v2-a650d2d42e0ed880c4413340ec961a27_hd.jpg" alt="传送门"></p><p>如果还不明白Portal是啥，那就拿范冰冰在《X战警：逆转未来》所演角色的GIF动图来看吧。<br><img src="https://pic1.zhimg.com/v2-89a003124def7b845832f3789ba8c4e8_b.jpg" alt="《X战警：逆转未来》"></p><p>你看一个哨兵机器人扑过来攻击一个X战警，范冰冰从一个传送门里神速穿越而来，顺手又甩出两个传送门，让哨兵机器人扑进了一个传送门，从另一个传送门一个踉跄掉了出来，从而救了那个X战警。</p><p>现在明白Portal是怎么回事了吧。</p><h2 id="为什么react需要传送门？">为什么React需要传送门？</h2><p>React Portal之所以叫Portal，因为做的就是和“传送门”一样的事情：<strong>render到一个组件里面去，实际改变的是网页上另一处的DOM结构</strong>。</p><p>在React的世界中，一切都是组件，用组件可以表示一切界面中发生的逻辑，不过，有些特例处理起来还比较麻烦，比如，某个组件在渲染时，在某种条件下需要显示一个对话框(Dialog)，这该怎么做呢？</p><p>最直观的做法，就是直接在JSX中把Dialog画出来，像下面代码的样子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"foo"</span>&gt;</span><br><span class="line">   &lt;div&gt; ... &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">   &#123; needDialog ? &lt;Dialog /</span>&gt; : <span class="literal">null</span> &#125;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure><p>问题是，我们写一个Dialog组件，就这么渲染的话，Dialog最终渲染产生的HTML就存在于上面JSX产生的HTML一起了，类似下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"foo"</span>&gt;</span><br><span class="line">   &lt;div&gt; ... &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">   &lt;div class="dialog"&gt;Dialog Content&lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure><p>可是问题来了，对于对话框，从用户感知角度，应该是一个独立的组件，通常应该显示在屏幕的最中间，现在Dialog被包在其他组件中，要用CSS的position属性控制Dialog位置，就要求从Dialog往上一直到body没有其他postion是relative的元素干扰，这……有点难为作为通用组件的Dialog，毕竟，谁管得住所有组件不用position呢。</p><p>还有一点，Dialog的样式，因为包在其他元素中，各种样式纠缠，CSS样式太容易搞成一坨浆糊了。</p><h3 id="when-to-use-react传送门？-liyuankun-增加">When to use React传送门？【liyuankun 增加】</h3><p>当父组件样式有 overflow: hidden 或者 z-index，但是你需要子组件看起来“break out”它所在的container. 例如dialogs, hover cards 和 tool-tips.</p><h3 id="react-16-之前怎么实现传送门？">React 16 之前怎么实现传送门？</h3><p>看样子这样搞局限很多啊，行不通，有没有其他办法？</p><h4 id="通过redux或者其他通讯方式">通过Redux或者其他通讯方式</h4><p>有一个其他办法，就是在React组件树的最顶层留一个元素专属于Dialog，然后通过Redux或者其他什么通讯方式给这个Dialog发送信号，让Dialog显示或者不显示。<br><img src="https://pic1.zhimg.com/80/v2-4022e89a8d7a22461e426cf6c653e18c_hd.jpg" alt="Dialog"><br>这种方法看起来还凑合着，但是，就这点事还要动用Redux有点高射炮打蚊子，而且，要控制两个不用位置的组件，好麻烦。</p><p>而且，如果我们把Dialog做成一个通用组件，希望里面的内容完全定制，这招就更加麻烦了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"foo"</span>&gt;</span><br><span class="line">  &lt;div&gt; ... &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &#123; needDialog ? </span></span><br><span class="line"><span class="regexp">    &lt;Dialog&gt; </span></span><br><span class="line"><span class="regexp">       &lt;header&gt;Any Header&lt;/</span>header&gt;</span><br><span class="line">       &lt;section&gt;Any content&lt;<span class="regexp">/section&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Dialog&gt;</span><br><span class="line">    : <span class="literal">null</span> &#125;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure><p>像上面那样，我们既希望在组件的JSX中选择使用Dialog，把Dialog用得像一个普通组件一样，但是又希望Dialog内容显示在另一个地方，就需要Portal上场了。</p><p>Portal就是建立一个“传送门”，让Dialog这样的组件在表示层和其他组件没有任何差异，但是渲染的东西却像经过传送门一样出现在另一个地方。</p><h4 id="react-15-api">React 15 API</h4><p>React在v16之前的传送门实现方法<br>在v16之前，实现“传送门”，要用到两个秘而不宣的React API</p><ul><li>unstable_renderSubtreeIntoContainer</li><li>unmountComponentAtNode</li></ul><p>第一个unstable_renderSubtreeIntoContainer，都带上前缀unstable了，就知道并不鼓励使用，但是没办法啊，不用也得用，还好React一直没有deprecate这个API，一直挺到v16直接支持portal。这个API的作用就是建立“传送门”，可以把JSX代表的组件结构塞到传送门里面去，让他们在传送门的另一端渲染出来。</p><p>第二个unmountComponentAtNode用来清理第一个API的副作用，通常在unmount的时候调用，不调用的话会造成资源泄露的。</p><p>一个通用的Dialog组件的实现差不多是这样，注意看renderPortal中的注释。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;unstable_renderSubtreeIntoContainer, unmountComponentAtNode&#125; </span><br><span class="line">  <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dialog</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">const</span> doc = <span class="built_in">window</span>.document;</span><br><span class="line">    <span class="keyword">this</span>.node = doc.createElement(<span class="string">'div'</span>);</span><br><span class="line">    doc.body.appendChild(<span class="keyword">this</span>.node);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.renderPortal(<span class="keyword">this</span>.props);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate() &#123;</span><br><span class="line">    <span class="keyword">this</span>.renderPortal(<span class="keyword">this</span>.props);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    unmountComponentAtNode(<span class="keyword">this</span>.node);</span><br><span class="line">    <span class="built_in">window</span>.document.body.removeChild(<span class="keyword">this</span>.node);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  renderPortal(props) &#123;</span><br><span class="line">    unstable_renderSubtreeIntoContainer(</span><br><span class="line">      <span class="keyword">this</span>, <span class="comment">//代表当前组件</span></span><br><span class="line">      &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"dialog"</span>&gt;</span><br><span class="line">        &#123;props.children&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;, /</span><span class="regexp">/ 塞进传送门的JSX</span></span><br><span class="line"><span class="regexp">      this.node /</span><span class="regexp">/ 传送门另一端的DOM node</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>首先，render函数不要返回有意义的JSX，也就说说这个组件通过正常生命周期什么都不画，要是画了，那画出来的HTML/DOM就直接出现在使用Dialog的位置了，这不是我们想要的。</p><p>在componentDidMount里面，利用原生API来在body上创建一个div，这个div的样式绝对不会被其他元素的样式干扰。</p><p>然后，无论componentDidMount还是componentDidUpdate，都调用一个renderPortal来往“传送门”里塞东西。</p><p>总结，这个Dialog组件做得事情是这样：</p><ol><li>它什么都不给自己画，render返回一个null就够了；</li><li>它做得事情是通过调用renderPortal把要画的东西画在DOM树上另一个角落。</li></ol><p>在renderPortal中，利用unstable_renderSubtreeIntoContainer函数往直前创建的div里塞JSX，这里我们用的JSX是这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"dialog"</span>&gt;</span><br><span class="line">     &#123;props.children&#125;</span><br><span class="line"> &lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure><p>因为是吧children画出来，所以使用Dialog可以加上任意的子组件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Dialog&gt;</span><br><span class="line">     What ever shit</span><br><span class="line">     &lt;div&gt;Hello&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">     &lt;p&gt;World&lt;/</span>p&gt;</span><br><span class="line"> &lt;<span class="regexp">/Dialog&gt;</span></span><br></pre></td></tr></table></figure><p>你看，所谓React Portal，就是能够表面上渲染在一个地方，实际上渲染到了另一个地方。<br><img src="https://pic4.zhimg.com/80/v2-60771cc0b94e780ca29bdd72f2761d57_hd.jpg" alt="Portal"></p><p>是不是感觉好厉害，不光好厉害，而且像Dialog这样的场景Portal简直就是必不可少。</p><p>到了v16，React干脆直接支持Portal，当然，v15还将被使用一段时间，所以大家看了上面的内容也不算浪费时间:-)</p><h2 id="react-v16的portal支持">React v16的Portal支持</h2><p>在v16中，使用Portal创建Dialog组件简单多了，不需要牵扯到componentDidMount、componentDidUpdate，也不用调用API清理Portal，关键代码在render中，像下面这样就行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;createPortal&#125; <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dialog</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>(...arguments);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> doc = <span class="built_in">window</span>.document;</span><br><span class="line">    <span class="keyword">this</span>.node = doc.createElement(<span class="string">'div'</span>);</span><br><span class="line">    doc.body.appendChild(<span class="keyword">this</span>.node);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> createPortal(</span><br><span class="line">      &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"dialog"</span>&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.props.children&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;, /</span><span class="regexp">/塞进传送门的JSX</span></span><br><span class="line"><span class="regexp">      this.node /</span><span class="regexp">/传送门的另一端DOM node</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  componentWillUnmount() &#123;</span></span><br><span class="line"><span class="regexp">    window.document.body.removeChild(this.node);</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>v16提供createPortal函数来创建“传送门”，我个人觉得这个函数应该叫renderPortal好一些，因为组件的render函数除了mount时会被调用，update时也会被调用，update时还叫createPortal有点不大合适。</p><h2 id="穿越portal的事件冒泡">穿越Portal的事件冒泡</h2><p>v16之前的React Portal实现方法，有一个小小的缺陷，就是Portal是单向的，内容通过Portal传到另一个出口，在那个出口DOM上发生的事件是不会冒泡传送回进入那一端的。</p><p>也就是说，这样的代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div onClick=&#123;onDialogClick&#125;&gt;   </span><br><span class="line">   &lt;Dialog&gt;</span><br><span class="line">     What ever shit</span><br><span class="line">   &lt;<span class="regexp">/Dialog&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure><p>在Dialog画出的内容上点击，onDialogClick是不会被触发的。</p><p>当然，这只是一个小小的缺陷，大部分场景下事件不传过来也没什么大问题。</p><p>在v16中，通过Portal渲染出去的DOM，事件是会冒泡从传送门的入口端冒出来的，上面的onDialogClick也就会被调用到了。</p><h3 id="why事件冒泡可以到react-parent-liyuankun-增加">why事件冒泡可以到react parent 【liyuankun 增加】</h3><p>可以看这个例子：<a href="https://codepen.io/catherineliyuankun/pen/oNvpxKv" target="_blank" rel="noopener">Dialog 嵌套 Dialog demo</a></p><p>从真实的DOM结构上来看，Dialog组件中的onClick事件不应该被</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span>Here contain Dialog:<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>组件捕获。<br>但从虚拟DOM的结构上来看，Dialog却是&quot;container&quot;组件的子节点，事件冒泡是遵循虚拟DOM的.</p><p>真实的DOM结构:<br><img src="https://github.com/CatherineLiyuankun/PictureBed/raw/master/blog/post/React-16-Portal/Real%20Dom%201.png" alt="真实的DOM结构1"><br><img src="https://github.com/CatherineLiyuankun/PictureBed/raw/master/blog/post/React-16-Portal/Real%20Dom%202.png" alt="真实的DOM结构2"></p><p>虚拟DOM的结构:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div onClick=&#123;onDialogClick&#125;&gt;</span><br><span class="line">  &lt;div className=<span class="string">"container"</span>&gt;</span><br><span class="line">    Here contain Dialog:</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;Dialog onClick=&#123;onDialog1Click&#125;&gt;</span></span><br><span class="line"><span class="regexp">     &lt;div&gt;Dialog 1&lt;/</span>div&gt;</span><br><span class="line">      &lt;Dialog onClick=&#123;onDialog2Click&#125;&gt;</span><br><span class="line">        &lt;div&gt;Dialog <span class="number">2</span> Inside Dialog <span class="number">1</span> &lt;<span class="regexp">/div&gt;    </span></span><br><span class="line"><span class="regexp">      &lt;/</span>Dialog&gt;</span><br><span class="line">  &lt;<span class="regexp">/Dialog&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><p>React v16直接支持Portal，是因为Portal这个功能真的是必不可少，不然对话框这样的场景都没法应付。</p><h2 id="reference-links">Reference Links</h2><ul><li><a href="https://react.docschina.org/docs/portals.html" target="_blank" rel="noopener">官网文档中文版</a></li><li><a href="https://zhuanlan.zhihu.com/p/29880992" target="_blank" rel="noopener">传送门：React Portal</a></li><li><a href="https://www.beautifulcode.co/blog/46-understanding-portals-in-react" target="_blank" rel="noopener">Understanding Portals in React</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转&lt;a href=&quot;https://zhuanlan.zhihu.com/p/29880992&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送门：React Portal&lt;/a&gt;， 在这个基础上做了小的修改。&lt;/p&gt;
&lt;p&gt;似乎所有说React Por
      
    
    </summary>
    
      <category term="TECH" scheme="https://catherineliyuankun.github.io/categories/TECH/"/>
    
      <category term="FrontEnd" scheme="https://catherineliyuankun.github.io/categories/TECH/FrontEnd/"/>
    
      <category term="React" scheme="https://catherineliyuankun.github.io/categories/TECH/FrontEnd/React/"/>
    
    
      <category term="React 16" scheme="https://catherineliyuankun.github.io/tags/React-16/"/>
    
  </entry>
  
  <entry>
    <title>React 16 - New feature Summary Links</title>
    <link href="https://catherineliyuankun.github.io/React-16-New-feature-Summary-Links.html"/>
    <id>https://catherineliyuankun.github.io/React-16-New-feature-Summary-Links.html</id>
    <published>2019-09-03T09:06:45.000Z</published>
    <updated>2019-11-04T17:06:42.398Z</updated>
    
    <content type="html"><![CDATA[<p>React<br><a href="https://github.com/facebook/react/blob/master/CHANGELOG.md" target="_blank" rel="noopener">https://github.com/facebook/react/blob/master/CHANGELOG.md</a></p><p>VersionFeatureHostTech Article<br>16.0.0 (September 26, 2017)</p><table><thead><tr><th>Version</th><th>Feature</th><th>Article Links</th></tr></thead><tbody><tr><td>16.0.0 (September 26, 2017)</td><td><a href="https://reactjs.org/blog/2017/07/26/error-handling-in-react-16.html" target="_blank" rel="noopener">Error boundaries</a></td><td><a href="../React-16-Error-Handling.html">Error boundaries</a></td></tr><tr><td>-</td><td>First-class support for declaratively rendering a subtree into another DOM node with <a href="https://reactjs.org/docs/portals.html#event-bubbling-through-portals" target="_blank" rel="noopener">ReactDOM.createPortal()</a></td><td><a href="../React-16-Portal.html">Portal</a></td></tr><tr><td>-</td><td><a href="https://reactjs.org/blog/2017/09/08/dom-attributes-in-react-16.html" target="_blank" rel="noopener">React DOM now allows passing non-standard attributes</a></td><td>DOM Attributes</td></tr><tr><td>16.2.0 (November 28, 2017)</td><td><a href="https://reactjs.org/blog/2017/11/28/react-v16.2.0-fragment-support.html" target="_blank" rel="noopener">Improved Support for Fragments</a></td><td>Fragments</td></tr><tr><td><a href="https://reactjs.org/blog/2018/03/29/react-v-16-3.html" target="_blank" rel="noopener">16.3.0 (March 29, 2018)</a></td><td><a href="https://reactjs.org/docs/context.html#contextprovider" target="_blank" rel="noopener">New officially supported context API</a></td><td>context API</td></tr><tr><td>16.2.0 (November 28, 2017)</td><td><a href="https://reactjs.org/docs/react-api.html#reactcreateref" target="_blank" rel="noopener">New React.createRef()</a></td><td>React.createRef</td></tr><tr><td>-</td><td><a href="https://reactjs.org/docs/react-api.html#reactforwardref" target="_blank" rel="noopener">New React.forwardRef()</a></td><td>React.forwardRef</td></tr><tr><td>-</td><td><a href="https://reactjs.org/blog/2017/11/28/react-v16.2.0-fragment-support.html" target="_blank" rel="noopener">StrictMode Component</a></td><td>Fragments</td></tr><tr><td>-</td><td>New lifecycles Add a new getDerivedStateFromProps() lifecycle and UNSAFE_ aliases for the legacy lifecycles.</td><td></td></tr></tbody></table><p>Add a new getSnapshotBeforeUpdate() lifecycle.<br><a href="https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html" target="_blank" rel="noopener">https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html</a> <a href="https://reactjs.org/blog/2017/11/28/react-v16.2.0-fragment-support.html" target="_blank" rel="noopener">Improved Support for Fragments</a> | Fragments</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;React&lt;br&gt;
&lt;a href=&quot;https://github.com/facebook/react/blob/master/CHANGELOG.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/facebook
      
    
    </summary>
    
      <category term="TECH" scheme="https://catherineliyuankun.github.io/categories/TECH/"/>
    
      <category term="FrontEnd" scheme="https://catherineliyuankun.github.io/categories/TECH/FrontEnd/"/>
    
      <category term="React" scheme="https://catherineliyuankun.github.io/categories/TECH/FrontEnd/React/"/>
    
    
      <category term="React 16" scheme="https://catherineliyuankun.github.io/tags/React-16/"/>
    
  </entry>
  
  <entry>
    <title>React 16 - Error Handling</title>
    <link href="https://catherineliyuankun.github.io/React-16-Error-Handling.html"/>
    <id>https://catherineliyuankun.github.io/React-16-Error-Handling.html</id>
    <published>2019-09-03T09:06:09.000Z</published>
    <updated>2019-09-03T13:12:15.894Z</updated>
    
    <content type="html"><![CDATA[<h2 id="react-15：">React 15：</h2><p>渲染过程中有出错，直接crash整个页面，并且错误信息不明确，可读性差.<br>一旦某个组件发生错误，整个组件树将会从根节点被unmount下来。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuggyCounter</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">counter</span>: <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  componentWillMount() &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'I am crash'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function">(<span class="params">&#123;counter&#125;</span>) =&gt;</span> (&#123;</span><br><span class="line">      counter: counter + <span class="number">1</span></span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.state.counter === <span class="number">5</span>) &#123;</span><br><span class="line">      <span class="comment">// Simulate a JS error</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'I crashed!'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>&#123;this.state.counter&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;</span><br><span class="line">        &lt;b&gt;</span><br><span class="line">          This is an example <span class="keyword">of</span> error boundaries <span class="keyword">in</span> React <span class="number">16.</span></span><br><span class="line">          &lt;br /&gt;<span class="xml"><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line"><span class="xml">          Click on the numbers to increase the counters.</span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line"><span class="xml">          The counter is programmed to throw when it reaches 5. This simulates a JavaScript error in a component.</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">b</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;hr /</span>&gt;</span><br><span class="line">        &lt;p&gt;These two counters are inside the same error boundary. If one crashes, the error boundary will replace both <span class="keyword">of</span> them.&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;BuggyCounter /</span>&gt;</span><br><span class="line">      &lt;hr /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(</span></span><br><span class="line"><span class="regexp">  &lt;App /</span>&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="demo地址"><a href="https://codepen.io/anon/pen/ErBjZM?editors=0010" target="_blank" rel="noopener">demo地址</a></h3><p>比如上面这个App，可以看到子组件BuggyCounter出了点问题，在没有Error Boundary的时候，整个App都会crash掉，所以显示白屏。</p><h2 id="react-16：">React 16：</h2><p>React之前没有提供一种合适的处理组件错误的方法，而React16.0中通过Error Boundaries来处理组件内部的错误，从而可以修正错误组件。<br>用于捕获子组件树的组件异常（即错误边界只可以捕获组件在树中比他低的组件错误。），记录错误并展示一个用Error Boundary提供的内容替代错误组件。</p><h3 id="捕获范围：">捕获范围：</h3><p>渲染期间<br>生命周期内<br>整个组件树构造函数内</p><h3 id="如何使用：">如何使用：</h3><p>最佳实践：</p><ul><li>如果一个 class 组件中定义了 static getDerivedStateFromError() 或 componentDidCatch() 这两个生命周期方法中的任意一个（或两个）时，那么它就变成一个错误边界。当抛出错误后，请使用 static getDerivedStateFromError() 渲染备用 UI ，使用 componentDidCatch() 打印错误信息。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ErrorBoundary</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">hasError</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> getDerivedStateFromError(error) &#123;</span><br><span class="line">    <span class="comment">// 更新 state 使下一次渲染能够显示降级后的 UI</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">hasError</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidCatch(error, info) &#123;</span><br><span class="line">    <span class="comment">// 你同样可以将错误日志上报给服务器</span></span><br><span class="line">    logErrorToMyService(error, info);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.state.hasError) &#123;</span><br><span class="line">      <span class="comment">// 你可以自定义降级后的 UI 并渲染</span></span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Something went wrong.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.props.children; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>将ErrorBoundary抽象为一个公用的组件类， 我们可以在容易出错的组件外使用ErrorBoundary将它包裹起来。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ErrorBoundary&gt;</span><br><span class="line">  &lt;MyWidget /&gt;</span><br><span class="line">&lt;<span class="regexp">/ErrorBoundary&gt;</span></span><br></pre></td></tr></table></figure><h3 id="componentdidcatch-生命周期函数">componentDidCatch（）生命周期函数</h3><p>componentDidCatch是一个新的生命周期函数，当组件有了这个生命周期函数，就成为了一个Error Boundaries。下面我们来看componnetDidCatch()中的参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">componentDidCatch(error, info) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>error参数，表示的是被抛出的错误的信息，而info是一个对象包含了组件堆栈中的信息（也就是在发生错误的子组件中层层传递错误信息，到顶层的Error Boundaries，每一层中的组件名）。</p><h3 id="component-stack-traces">Component Stack Traces</h3><p>下面我们来看组件堆栈轨迹，我们假设这样一个结构：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;App&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">      &lt;ErrorBoundary&gt;</span><br><span class="line">        &lt;Child&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/ErrorBoundary&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/App&gt;</span></span><br></pre></td></tr></table></figure><p>如果在Child组件中发生了js错误，那么堆栈的报错信息应该如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">the error is located at :</span><br><span class="line">     <span class="keyword">in</span> Child  (created by App)</span><br><span class="line">     <span class="keyword">in</span> ErrorBoundary(created by App)</span><br><span class="line">     <span class="keyword">in</span> div (created by App)</span><br><span class="line">     <span class="keyword">in</span> App</span><br></pre></td></tr></table></figure><p>如果需要报错信息显示错误组件所在的具体的行数和位置，可以使用babel-plugin-transform-react-jsx-source插件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先定一个组件ErrorBoundary</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ErrorBoundary</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">error</span>: <span class="literal">null</span>, <span class="attr">errorInfo</span>: <span class="literal">null</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  componentDidCatch(error, errorInfo) &#123;</span><br><span class="line">    <span class="comment">// Catch errors in any components below and re-render with error message</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      error: error,</span><br><span class="line">      errorInfo: errorInfo</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// You can also log error messages to an error reporting service here</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// 有错误的时候展示回退</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.state.errorInfo) &#123;</span><br><span class="line">      <span class="comment">// Error path</span></span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;h2&gt;Something went wrong.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">          &lt;details style=&#123;&#123; whiteSpace: 'pre-wrap' &#125;&#125;&gt;</span></span><br><span class="line"><span class="regexp">            &#123;this.state.error &amp;&amp; this.state.error.toString()&#125;</span></span><br><span class="line"><span class="regexp">            &lt;br /</span>&gt;</span><br><span class="line">            &#123;<span class="keyword">this</span>.state.errorInfo.componentStack&#125;</span><br><span class="line">          &lt;<span class="regexp">/details&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 正常的话，直接展示组件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.props.children;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuggyCounter</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">counter</span>: <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  componentWillMount() &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'I am crash'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function">(<span class="params">&#123;counter&#125;</span>) =&gt;</span> (&#123;</span><br><span class="line">      counter: counter + <span class="number">1</span></span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.state.counter === <span class="number">5</span>) &#123;</span><br><span class="line">      <span class="comment">// Simulate a JS error</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'I crashed!'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>&#123;this.state.counter&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;</span><br><span class="line">        &lt;b&gt;</span><br><span class="line">          This is an example <span class="keyword">of</span> error boundaries <span class="keyword">in</span> React <span class="number">16.</span></span><br><span class="line">          &lt;br /&gt;<span class="xml"><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line"><span class="xml">          Click on the numbers to increase the counters.</span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line"><span class="xml">          The counter is programmed to throw when it reaches 5. This simulates a JavaScript error in a component.</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">b</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;hr /</span>&gt;</span><br><span class="line">        &lt;ErrorBoundary&gt;</span><br><span class="line">        &lt;p&gt;These two counters are inside the same error boundary. If one crashes, the error boundary will replace both <span class="keyword">of</span> them.&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;BuggyCounter /</span>&gt;</span><br><span class="line">        &lt;<span class="regexp">/ErrorBoundary&gt;</span></span><br><span class="line"><span class="regexp">      &lt;hr /</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(</span></span><br><span class="line"><span class="regexp">  &lt;App /</span>&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="demo地址-v2"><a href="https://codepen.io/gaearon/pen/wqvxGa?editors=0010" target="_blank" rel="noopener">demo地址</a></h3><p>可以看到加上Error Boundary之后，除了出错的组件，其他的地方都不受影响。</p><p>而且它很清晰的告诉我们是哪个组件发生了错误。</p><h3 id="注意事项：">注意事项：</h3><p>Error Boundary无法捕获下面的错误：</p><ol><li>事件函数里的错误</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">error</span>: <span class="literal">null</span> &#125;;</span><br><span class="line">    <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Do something that could throw</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; error &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.state.error) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Caught an error.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子中，handleClick方法里面发生的错误，Error Boundary是捕获不到的。因为它不发生在渲染阶段，所以采用try/catch来捕获。</p><ol start="2"><li>异步代码（例如setTimeout 或 requestAnimationFrame 回调函数）</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">     render() &#123;</span><br><span class="line">        <span class="comment">// 此错误无法被捕获，渲染时组件正常返回 `&lt;div&gt;&lt;/div&gt;`</span></span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error'</span>)</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>服务端渲染</li></ol><p>因为服务器渲染不支持Error Boundary</p><ol start="4"><li>Error Boundary自身抛出来的错误 （而不是其子组件）</li></ol><h3 id="错误边界放在哪里">错误边界放在哪里?</h3><p>一般来说，有两个地方：</p><ol><li><p>可以放在顶层，告诉用户有东西出错。但是我个人不建议这样，这感觉失去了错误边界的意义。因为有一个组件出错了，其他正常的也没办法正常显示了</p></li><li><p>包在子组件外面，保护其他应用不崩溃。</p></li></ol><h2 id="reference-links">Reference Links</h2><ul><li><a href="https://react.docschina.org/docs/error-boundaries.html" target="_blank" rel="noopener">官网文档中文版</a></li><li><a href="https://reactjs.org/blog/2017/07/26/error-handling-in-react-16.html" target="_blank" rel="noopener">React Error Handling in React 16</a></li><li><a href="https://my.oschina.net/u/2332658/blog/3019283" target="_blank" rel="noopener">React16新特性</a></li><li><a href="https://zhuanlan.zhihu.com/p/57544233" target="_blank" rel="noopener">React 16 新特性全解（上）</a></li><li><a href="https://blog.csdn.net/liwusen/article/details/78521006" target="_blank" rel="noopener">React 16.0中的新特性——Error Boundaries及其注意点</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;react-15：&quot;&gt;React 15：&lt;/h2&gt;
&lt;p&gt;渲染过程中有出错，直接crash整个页面，并且错误信息不明确，可读性差.&lt;br&gt;
一旦某个组件发生错误，整个组件树将会从根节点被unmount下来。&lt;/p&gt;
&lt;figure class=&quot;highlight
      
    
    </summary>
    
      <category term="TECH" scheme="https://catherineliyuankun.github.io/categories/TECH/"/>
    
      <category term="FrontEnd" scheme="https://catherineliyuankun.github.io/categories/TECH/FrontEnd/"/>
    
      <category term="React" scheme="https://catherineliyuankun.github.io/categories/TECH/FrontEnd/React/"/>
    
    
      <category term="React 16" scheme="https://catherineliyuankun.github.io/tags/React-16/"/>
    
  </entry>
  
  <entry>
    <title>cryptic abbreviations of Github comments</title>
    <link href="https://catherineliyuankun.github.io/cryptic-abbreviations-of-Github-comments.html"/>
    <id>https://catherineliyuankun.github.io/cryptic-abbreviations-of-Github-comments.html</id>
    <published>2019-08-08T18:31:39.000Z</published>
    <updated>2019-08-08T12:53:47.788Z</updated>
    
    <content type="html"><![CDATA[<p>我们Github code review 的时候第一次遇到这些缩写时，一脸懵逼，一无所知脸的偷偷去搜搜是什么意思？<br>这里整理一下这些缩写都是什么含义，以后我们也可以欢快地装逼了，装作娴熟的司机们来使用缩写来达到提高逼格的效果~~</p><ul><li>PR: Pull Request. 拉取请求，给其他项目提交代码</li><li>LGTM: Looks Good To Me. <s>朕知道了</s> 代码已review，可以合并</li><li>SGTM: Sounds Good To Me. 和上面那句意思差不多，也是已经通过了 review 的意思</li><li>ACK — acknowledgement, i.e. agreed/accepted change 同意/接受改动</li><li>NACK/NAK —negative acknowledgement, i.e. disagree with change and/or concept 不同意/接受改动</li><li>RFC — request for comments, i.e. I think this is a good idea, lets discuss 我觉得不错，你怎么看？</li><li>AFAIK/AFAICT — as far as I know / can tell 据我所知</li><li>IIRC — if I recall correctly 如果我recall的正确的话</li><li>IANAL — “I am not a lawyer”, but I smell licensing issues</li><li>WIP: Work In Progress, do not merge yet. 传说中提 PR 的最佳实践是，如果你有个改动很大的 PR，可以在写了一部分的情况下先提交，但是在标题里写上 WIP，以告诉项目维护者这个功能还未完成，方便维护者提前 review 部分提交的代码。</li><li>PTAL: Please Take A Look. 你来瞅瞅？用来提示别人来看一下</li><li>TBR: To Be Reviewed. 提示维护者进行 review</li><li>TL;DR: Too Long; Didn’t Read. 太长懒得看。也有很多文档在做简略描述之前会写这么一句</li><li>TBD: To Be Done(or Defined/Discussed/Decided/Determined). 根据语境不同意义有所区别，但一般都是还没搞定的意思</li></ul><p>有些也使用比特币的黑客术语：</p><ul><li>Concept ACK — agree with the concept, but haven’t reviewed the changes 理论上同意，但我还没review过。。。</li><li>utACK (aka. Untested ACK) — agree with the changes and reviewed them, but didn’t test review过并同意改动，但我没测过~~~</li><li>Tested ACK — agree with the changes, reviewed and tested 同意改动，我也review过并测过了</li></ul><p>Reference links:<br><a href="https://farer.org/2017/03/01/code-review-acronyms/" target="_blank" rel="noopener">LGTM? 那些迷之缩写</a><br><a href="https://www.freecodecamp.org/news/what-do-cryptic-github-comments-mean-9c1912bcc0a4/" target="_blank" rel="noopener">What do cryptic Github comments mean?</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们Github code review 的时候第一次遇到这些缩写时，一脸懵逼，一无所知脸的偷偷去搜搜是什么意思？&lt;br&gt;
这里整理一下这些缩写都是什么含义，以后我们也可以欢快地装逼了，装作娴熟的司机们来使用缩写来达到提高逼格的效果~~&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PR: P
      
    
    </summary>
    
      <category term="TECH" scheme="https://catherineliyuankun.github.io/categories/TECH/"/>
    
      <category term="SE life" scheme="https://catherineliyuankun.github.io/categories/TECH/SE-life/"/>
    
    
      <category term="git" scheme="https://catherineliyuankun.github.io/tags/git/"/>
    
      <category term="abbr" scheme="https://catherineliyuankun.github.io/tags/abbr/"/>
    
  </entry>
  
  <entry>
    <title> Mac 上优化储存空间</title>
    <link href="https://catherineliyuankun.github.io/Mac-%E4%B8%8A%E4%BC%98%E5%8C%96%E5%82%A8%E5%AD%98%E7%A9%BA%E9%97%B4.html"/>
    <id>https://catherineliyuankun.github.io/Mac-上优化储存空间.html</id>
    <published>2019-07-11T09:08:39.000Z</published>
    <updated>2019-07-11T03:20:33.212Z</updated>
    
    <content type="html"><![CDATA[<ol><li><a href="https://support.apple.com/zh-cn/guide/system-information/sysp4ee93ca4/mac" target="_blank" rel="noopener">在 Mac 上优化储存空间</a></li></ol><ol start="2"><li><a href="https://support.apple.com/zh-cn/HT206996" target="_blank" rel="noopener">如何释放 Mac 上的储存空间</a></li></ol><ol start="3"><li><a href="https://blog.csdn.net/nynkl/article/details/78050495" target="_blank" rel="noopener">Mac 下清理硬盘空间大小 很实用哦。</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://support.apple.com/zh-cn/guide/system-information/sysp4ee93ca4/mac&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;在 Mac 上优化储存空间&lt;/a
      
    
    </summary>
    
      <category term="TECH" scheme="https://catherineliyuankun.github.io/categories/TECH/"/>
    
      <category term="Tools" scheme="https://catherineliyuankun.github.io/categories/TECH/Tools/"/>
    
    
      <category term="Mac" scheme="https://catherineliyuankun.github.io/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>hexo-reference path for link to another blog post</title>
    <link href="https://catherineliyuankun.github.io/hexo-reference%20path%20for%20link%20to%20another%20blog%20post.html"/>
    <id>https://catherineliyuankun.github.io/hexo-reference path for link to another blog post.html</id>
    <published>2019-07-10T14:55:24.000Z</published>
    <updated>2019-11-04T16:40:39.773Z</updated>
    
    <content type="html"><![CDATA[<h2 id="需求">需求</h2><p>Hexo blog里面，需要一篇文章里link到另一篇文章。最好是相对路径，绝对路径容易出错，而且不灵活，一换域名所有的link都不能用了。</p><h2 id="hexo的路径生成">Hexo的路径生成</h2><p>我们可以看到Hexo的路径生成：</p><p>例子1：<br><a href="http://localhost:4000/2019/06/11/BlogName1/" target="_blank" rel="noopener">http://localhost:4000/2019/06/11/BlogName1/</a></p><p>例子2：<br><a href="http://liyuankun.top/2019/06/11/Changing-SSL-port-from-8443-to-443/" target="_blank" rel="noopener">http://liyuankun.top/2019/06/11/Changing-SSL-port-from-8443-to-443/</a></p><blockquote><p>域名：端口/YYYY/MM/DD/BlogName</p></blockquote><blockquote><p>域名/YYYY/MM/DD/BlogName</p></blockquote><p>YYYY/MM/DD 是BlogName的创建时间，date: 2019-06-11 16:55:24</p><h2 id="解决方法">解决方法</h2><p>例子1：</p><p>在BlogName1里面link到BlogName2 的链接就为：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">当_config.yml  permalink: :year/:month/:day/:title/</span><br><span class="line">[<span class="string">BlogName2</span>](<span class="link">../../../../2019/06/11/BlogName2</span>)</span><br><span class="line">或</span><br><span class="line">当_config.yml permalink: :title.html</span><br><span class="line">[<span class="string">BlogName2</span>](<span class="link">../BlogName2.html</span>)</span><br></pre></td></tr></table></figure><p>2019/06/11 必须是BlogName2的date</p><p>例子2：</p><p>本篇文章link到文章“Changing SSL port from 8443 to 443”</p><p>markdown写为：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">当_config.yml  permalink: :year/:month/:day/:title/</span><br><span class="line"></span><br><span class="line">[<span class="string">Changing-SSL-port-from-8443-to-443</span>](<span class="link">../../../../2019/06/11/Changing-SSL-port-from-8443-to-443/</span>)</span><br><span class="line">或</span><br><span class="line">当_config.yml permalink: :title.html</span><br><span class="line">[<span class="string">Changing-SSL-port-from-8443-to-443</span>](<span class="link">../Changing-SSL-port-from-8443-to-443.html</span>)</span><br></pre></td></tr></table></figure><p>效果为：<br>当_config.yml  permalink: :year/:month/:day/:title/<br><a href="../../../../2019/06/11/Changing-SSL-port-from-8443-to-443/">Changing-SSL-port-from-8443-to-443</a><br>或<br>当_config.yml permalink: :title.html<br><a href="../Changing-SSL-port-from-8443-to-443.html">Changing-SSL-port-from-8443-to-443</a></p><h2 id="参考">参考</h2><p><a href="https://markdown-zh.readthedocs.io/en/latest/spanelements/" target="_blank" rel="noopener">Markdown 中文文档 内联元素</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;需求&quot;&gt;需求&lt;/h2&gt;
&lt;p&gt;Hexo blog里面，需要一篇文章里link到另一篇文章。最好是相对路径，绝对路径容易出错，而且不灵活，一换域名所有的link都不能用了。&lt;/p&gt;
&lt;h2 id=&quot;hexo的路径生成&quot;&gt;Hexo的路径生成&lt;/h2&gt;
&lt;p&gt;我们可以看
      
    
    </summary>
    
      <category term="TECH" scheme="https://catherineliyuankun.github.io/categories/TECH/"/>
    
      <category term="Hexo" scheme="https://catherineliyuankun.github.io/categories/TECH/Hexo/"/>
    
    
      <category term="Hexo" scheme="https://catherineliyuankun.github.io/tags/Hexo/"/>
    
      <category term="Blog" scheme="https://catherineliyuankun.github.io/tags/Blog/"/>
    
  </entry>
  
</feed>
